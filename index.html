<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Desafíos Mentales - Edición Estratégica Avanzada</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css?family=Fredoka+One&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Estilos Generales (del juego principal) */
        body {
            font-family: 'Nunito', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            line-height: 1.6;
            color: #4A5568; /* cool-gray-700 */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* indigo-500 to purple-700 gradient */
            padding: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .container {
            background-color: rgba(255, 255, 255, 0.97); /* White with slight transparency */
            padding: 25px 35px;
            border-radius: 20px; /* Increased border-radius */
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2), 0 8px 15px rgba(0,0,0,0.18); /* Softer, deeper shadow */
            text-align: center;
            max-width: 750px; /* Max width for larger screens */
            width: 100%;
            box-sizing: border-box;
            transition: transform 0.3s ease-out;
            min-height: 680px; /* Ensure enough height for content */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative; /* For potential absolute positioned elements inside */
        }

        .container:hover {
            transform: translateY(-6px); /* Subtle lift on hover */
        }

        button, .button-style {
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 10px; /* Slightly more rounded */
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            box-shadow: 0 5px 8px rgba(0,0,0,0.12);
            margin: 8px;
            font-family: 'Fredoka One', cursive;
            font-weight: 400; /* Fredoka One is often used at 400 */
        }

        button:hover, .button-style:hover {
            transform: translateY(-3px) scale(1.03); /* More interactive hover */
            box-shadow: 0 7px 12px rgba(0,0,0,0.18);
        }

        button:active, .button-style:active {
            transform: translateY(-1px) scale(0.98);
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        button:disabled, .button-style:disabled {
            background-color: #A0AEC0 !important; /* cool-gray-400 */
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 5px 8px rgba(0,0,0,0.08);
        }

        .welcome-screen { /* Keep this for the initial name input */
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: fadeIn 0.5s ease-out;
        }
        .temporary-welcome-screen { /* New style for temporary welcome */
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px;
            animation: fadeIn 0.5s ease-out;
            min-height: 300px; /* Or adjust as needed */
        }
        .temporary-welcome-screen h1 {
            color: #5A67D8; /* indigo-600 */
            margin-bottom: 20px;
            font-size: 2.4em;
            font-family: 'Fredoka One', cursive;
        }
        .temporary-welcome-screen p {
            font-size: 1.2em;
            color: #4A5568; /* cool-gray-700 */
        }


        .welcome-screen h1 {
            color: #5A67D8; /* indigo-600 */
            margin-bottom: 15px;
            font-size: 2.6em; /* Slightly larger */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
            font-family: 'Fredoka One', cursive;
        }

        .welcome-screen p {
            font-size: 1.15em;
            margin-bottom: 12px;
            color: #5f6c80; /* Adjusted for better contrast */
        }

        .welcome-screen input[type="text"], .welcome-screen input[type="password"] {
            padding: 14px 18px; /* More padding */
            margin-bottom: 18px;
            border: 2px solid #CBD5E0; /* cool-gray-300 */
            border-radius: 10px; /* More rounded */
            font-size: 1.2em;
            width: 90%;
            max-width: 320px;
            text-align: center;
            box-sizing: border-box;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Nunito', sans-serif;
        }

        .welcome-screen input[type="text"]:focus, .welcome-screen input[type="password"]:focus {
            border-color: #5A67D8; /* indigo-600 */
            box-shadow: 0 0 0 4px rgba(90, 103, 216, 0.25); /* Focus ring */
            outline: none;
        }

        .welcome-screen button {
            background-color: #48BB78; /* green-500 */
            margin-top: 10px;
        }
        .welcome-screen button:hover {
            background-color: #3f9e6a; /* green-600 */
        }
        .auth-error-message {
            color: #E53E3E; /* red-600 */
            font-size: 0.95em;
            margin-top:-10px;
            margin-bottom: 10px;
            display: none;
            font-weight: 600;
        }

        .selection-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            animation: slideInUp 0.6s ease-out;
        }

        .selection-screen h2 {
            color: #3a4b60; /* Darker shade for title */
            margin-bottom: 10px;
            font-size: 2.2em;
            font-family: 'Fredoka One', cursive;
        }
        .selection-screen .greeting-subtext {
            font-size: 1.1em;
            color: #6b7a90; /* Softer subtext color */
            margin-bottom: 15px;
        }

        .selection-screen .logout-button {
            background-color: #A0AEC0; /* cool-gray-400 */
            font-size: 0.8em;
            padding: 8px 15px;
            margin-top: 0;
            margin-bottom: 15px;
        }
        .selection-screen .logout-button:hover {
            background-color: #7f8c9b; /* cool-gray-500 */
        }

        .selection-screen .game-selection-buttons {
            margin-bottom: 25px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        .selection-screen .game-selection-buttons button {
            background-color: #4299E1; /* blue-500 */
            min-width: 220px; /* Ensure buttons have good width */
            margin: 8px;
        }
        .selection-screen .game-selection-buttons button:hover {
            background-color: #3582c0; /* blue-600 */
        }
        .selection-screen .game-selection-buttons button.game-mindtwist {
            background-color: #ED8936; /* orange-500 */
        }
        .selection-screen .game-selection-buttons button.game-mindtwist:hover {
            background-color: #d57b2f; /* orange-600 */
        }
         .selection-screen .game-selection-buttons button.game-simon {
             background-color: #38A169; /* green-600 */
         }
         .selection-screen .game-selection-buttons button.game-simon:hover {
             background-color: #2f855a; /* green-700 */
         }
         .selection-screen .game-selection-buttons button.game-number-memory {
             background-color: #805AD5; /* purple-600 */
         }
         .selection-screen .game-selection-buttons button.game-number-memory:hover {
             background-color: #6b46c1; /* purple-700 */
         }
         .selection-screen .game-selection-buttons button.game-sliding-puzzle {
             background-color: #B7791F; /* yellow-700 - Color para el nuevo juego */
         }
         .selection-screen .game-selection-buttons button.game-sliding-puzzle:hover {
             background-color: #975A16; /* yellow-800 */
         }
         .selection-screen .game-selection-buttons button.upcoming {
             background-color: #718096; /* cool-gray-500 */
         }
         .selection-screen .game-selection-buttons button.upcoming:hover {
             background-color: #5a6470; /* cool-gray-600 */
         }

        .selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 680px; /* Max width for the grid */
            margin-top: 20px;
        }

        .selection-card {
            background-color: #f7faff; /* Very light blue, almost white */
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); /* Softer shadow */
            text-align: left;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }
        .selection-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
        }

        .selection-card h3 {
            font-family: 'Fredoka One', cursive;
            color: #4a5a94; /* Dark blue-gray */
            font-size: 1.4em;
            margin-bottom: 12px;
            border-bottom: 2px solid #e2e8f0; /* cool-gray-200 */
            padding-bottom: 8px;
            text-align: center;
        }

        .selection-card p, .selection-card li {
            font-size: 1em;
            color: #5a677a; /* Mid blue-gray */
            margin-bottom: 6px;
        }
        .selection-card strong {
            color: #3d4a78; /* Darker for emphasis */
            font-weight: 700;
        }
        .selection-card ul {
            list-style: none;
            padding: 0;
        }
        .selection-card .leaderboard-list, .selection-card .medals-list-container {
            margin-top: 10px;
        }
        .selection-card .leaderboard-list li.leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px dotted #e2e8f0; /* cool-gray-200 */
        }
        .selection-card .leaderboard-list li.leaderboard-item:last-child {
            border-bottom: none;
        }
        .selection-card .leaderboard-list li.leaderboard-item.you {
            background-color: #EBF4FF; /* blue-100 */
            border-radius: 5px;
            padding: 5px 8px;
            font-weight: bold;
        }
        .selection-card .leaderboard-list strong { /* Score in leaderboard */
            color: #5A67D8; /* indigo-600 */
        }

        .selection-card .medals-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .selection-card .medal-item {
            font-size: 2.2em; /* Emoji size */
            position: relative;
            cursor: help;
            filter: grayscale(0%);
            transition: filter 0.3s ease-out;
        }
        .selection-card .medal-item.locked {
            filter: grayscale(100%);
            opacity: 0.6;
        }
        .selection-card .medal-item .medal-tooltip {
            visibility: hidden;
            opacity: 0;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px 12px;
            position: absolute;
            z-index: 1;
            bottom: 125%; /* Position above the medal */
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 0.8em;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: opacity 0.3s;
        }
        .selection-card .medal-item:hover .medal-tooltip {
            visibility: visible;
            opacity: 1;
        }
        .daily-bonus-container {
            padding: 15px;
            border-radius: 12px;
            background-color: #FFF7ED; /* orange-100 */
            border: 2px dashed #F6AD55; /* orange-400 */
            margin-top: 15px;
            text-align: center;
        }
        .daily-bonus-container h4 {
            font-family: 'Fredoka One', cursive;
            color: #D69E2E; /* yellow-600 */
            font-size: 1.5em;
            margin-bottom: 10px;
        }
        .daily-bonus-container p {
            color: #8B5E00; /* yellow-800, for text */
            font-size: 1.1em;
            margin-bottom: 15px;
        }
        .daily-bonus-container button {
            background-color: #F6AD55; /* orange-400 */
            margin-top: 0;
        }
        .daily-bonus-container button:hover {
            background-color: #ED8936; /* orange-500 */
        }

        /* Game Containers General */
        #math-game-container, #simon-game-container, #mind-twist-game-v2-container, #number-memory-game-container, #sliding-puzzle-game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            animation: zoomIn 0.4s ease-out;
        }

        .game-stats {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            margin-bottom: 18px;
            font-size: 1.05em;
            color: #718096; /* cool-gray-500 */
            padding: 8px 12px;
            background-color: #f8f9fa; /* Very light gray */
            border-radius: 10px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }
        .player-name-display {
            font-weight: 700;
            color: #5A67D8; /* indigo-600 */
            font-size: 1.1em;
        }
        .lives-display, .timer-display {
            font-weight: 700;
            font-size: 1.1em;
            color: #4A5568; /* cool-gray-700 */
        }
        .lives-display span, .timer-display span { /* The actual number/time */
            color: #DD6B20; /* orange-600 */
        }
        .timer-display.text-red-500 span { /* Tailwind class for urgent time */
            color: #E53E3E !important; /* red-600 */
            animation: pulseRed 1s infinite;
        }

        /* Estilos Mates */
        #math-game-container .level-info {
            font-size: 1.15em;
            color: #4A5568; /* cool-gray-700 */
            margin-bottom: 6px;
            font-weight: 600;
        }
        #math-game-container .progress-bar-container {
            width: 85%;
            max-width: 420px;
            height: 24px;
            background-color: #E2E8F0; /* cool-gray-200 */
            border-radius: 12px; /* Rounded to match height */
            margin-bottom: 18px;
            overflow: hidden;
            border: 1px solid #CBD5E0; /* cool-gray-300 */
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
        }
        #math-game-container .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #68D391, #48BB78); /* green-400 to green-500 */
            border-radius: 11px; /* Slightly less than container for inset look */
            transition: width 0.5s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.9em;
            font-weight: 600;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.2);
        }
        #math-game-container .problem {
            font-size: 2.3em;
            margin-bottom: 22px;
            color: #2D3748; /* cool-gray-800 */
            min-height: 1.6em; /* Ensure space even if problem is short */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping for long problems on small screens */
            padding: 12px 18px;
            background-color: #edf2f7; /* cool-gray-100 */
            border-radius: 10px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.07);
            font-family: 'Fredoka One', cursive;
        }
        #math-game-container .problem span {
            margin: 0 10px; /* Space around operator and numbers */
        }
        #math-game-container .input-area {
            margin-bottom: 22px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap; /* For smaller screens */
        }
        #math-game-container input[type="number"] {
            padding: 14px 18px;
            margin: 6px; /* Spacing around input */
            border: 2px solid #CBD5E0; /* cool-gray-300 */
            border-radius: 10px;
            font-size: 1.45em;
            width: 140px; /* Fixed width for answer */
            text-align: center;
            box-sizing: border-box;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Nunito', sans-serif;
        }
        #math-game-container input[type="number"]:focus {
            border-color: #63B3ED; /* blue-400 */
            box-shadow: 0 0 0 4px rgba(99, 179, 237, 0.25); /* Focus ring */
            outline: none;
        }
        #math-game-container .input-area button {
            background-color: #4299E1; /* blue-500 */
            margin-left: 12px; /* Space from input */
        }
        #math-game-container .input-area button:hover {
            background-color: #3582c0; /* blue-600 */
        }
        #math-game-container .result-area {
            margin-top: 18px;
            width: 100%;
        }
        #math-game-container .result {
            font-size: 1.25em;
            font-weight: 700;
            min-height: 1.6em; /* Ensure space for message */
            transition: transform 0.3s ease-out, background-color 0.3s ease, color 0.3s ease;
            padding: 12px 18px;
            border-radius: 10px;
            margin-bottom: 12px;
        }
        #math-game-container .result.correct {
            color: #2F855A; /* green-700 */
            background-color: #C6F6D5; /* green-100 */
            transform: scale(1.03);
            border: 1px solid #9AE6B4; /* green-300 */
        }
        #math-game-container .result.incorrect {
            color: #C53030; /* red-700 */
            background-color: #FED7D7; /* red-100 */
            animation: shake 0.5s;
            border: 1px solid #FEB2B2; /* red-300 */
        }
        #math-game-container .result.level-up {
            color: #B7791F; /* yellow-700 */
            background-color: #FEEBC8; /* orange-100 */
            transform: scale(1.08);
            animation: pulse 1s 1;
            border: 1px solid #FBD38D; /* orange-300 */
        }
        #math-game-container .result.level-down {
            color: #C53030; /* red-700 */
            background-color: #FED7D7; /* red-100 */
            animation: shake 0.8s;
            border: 1px solid #FEB2B2; /* red-300 */
        }
        #math-game-container .explanation {
            font-size: 0.95em;
            color: #4A5568; /* cool-gray-700 */
            margin-top: 8px;
            padding: 12px;
            background-color: #f7fafc; /* cool-gray-50 */
            border: 1px solid #e2e8f0; /* cool-gray-200 */
            border-radius: 10px;
            text-align: left;
            line-height: 1.55;
            max-height: 110px; /* Limit height and allow scroll */
            overflow-y: auto;
        }
        #math-game-container .explanation strong {
            color: #2D3748; /* cool-gray-800 */
        }
        #math-game-container .explanation code {
            background-color: #edf2f7; /* cool-gray-100 */
            padding: 3px 6px;
            border-radius: 5px;
            font-family: monospace;
            color: #2b6cb0; /* blue-700 */
        }

        .back-to-selection-btn {
            background-color: #A0AEC0; /* cool-gray-400 */
            margin-top: 25px;
            font-size: 1em;
            padding: 10px 18px;
        }
        .back-to-selection-btn:hover {
            background-color: #7f8c9b; /* cool-gray-500 */
        }

        /* Estilos MindTwist V2 */
        #mind-twist-game-v2-container {
            background-color: #f7faff; /* Very light blue */
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 550px;
        }
        #mind-twist-game-v2-container .game-title {
            font-family: 'Fredoka One', cursive;
            color: #ED8936; /* orange-500 */
            font-size: 2em;
            margin-bottom: 15px;
        }
        #mind-twist-game-v2-container .riddle-text {
            font-size: 1.25em;
            color: #4A5568; /* cool-gray-700 */
            margin-bottom: 20px;
            min-height: 2.5em;
        }
        #mind-twist-game-v2-container .options-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        #mind-twist-game-v2-container .option-button {
            background-color: #4299E1; /* blue-500 */
            color: white;
            padding: 12px;
            border-radius: 10px;
            font-size: 1.3em; /* Larger font for options */
            font-family: 'Nunito', sans-serif;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.15s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #mind-twist-game-v2-container .option-button:hover {
            background-color: #3582c0; /* blue-600 */
            transform: translateY(-2px);
        }
        #mind-twist-game-v2-container .feedback-text {
            font-size: 1em;
            font-weight: 600;
            min-height: 1.5em;
            margin-bottom: 15px;
        }
        #mind-twist-game-v2-container .feedback-text.correct { color: #38A169; /* green-600 */ }
        #mind-twist-game-v2-container .feedback-text.incorrect { color: #E53E3E; /* red-600 */ }
        #mind-twist-game-v2-container .feedback-text.hint { color: #4299E1; /* blue-500 */ }
        #mind-twist-game-v2-container .feedback-text.paused { color: #DD6B20; /* orange-600 */ }

        #mind-twist-game-v2-container .controls-area {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        #mind-twist-game-v2-container .control-button {
            font-size: 0.9em;
            padding: 10px 18px;
        }
        #mind-twist-game-v2-container #mt-v2-hint-btn { background-color: #4299E1; /* blue-500 */ }
        #mind-twist-game-v2-container #mt-v2-hint-btn:hover { background-color: #3582c0; /* blue-600 */ }
        #mind-twist-game-v2-container #mt-v2-pause-btn { background-color: #ED8936; /* orange-500 */ }
        #mind-twist-game-v2-container #mt-v2-pause-btn:hover { background-color: #d57b2f; /* orange-600 */ }
        #mind-twist-game-v2-container #mt-v2-next-btn {
            background-color: #38A169; /* green-600 */
            display: none; /* Initially hidden */
        }
        #mind-twist-game-v2-container #mt-v2-next-btn:hover { background-color: #2f855a; /* green-700 */ }


        /* Estilos Simon */
        #simon-game-container h2 {
            color: #38A169; /* green-600 */
            margin-bottom: 10px;
            font-size: 2.1em;
            font-family: 'Fredoka One', cursive;
        }
        #simon-game-container .cognitive-concept {
            font-size: 1em;
            color: #5a677a; /* Mid blue-gray */
            margin: 0 auto 15px auto;
            max-width: 80%;
            line-height: 1.5;
        }
        #simon-start-button {
            background-color: #38A169; /* green-600 */
            margin-bottom: 20px;
        }
        #simon-start-button:hover {
            background-color: #2f855a; /* green-700 */
        }
        #simon-pads-area {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px; /* Increased gap */
            width: 220px; /* Slightly larger pads area */
            height: 220px;
            margin: 0 auto 20px auto;
        }
        .simon-pad {
            border-radius: 15px; /* More rounded pads */
            cursor: pointer;
            transition: opacity 0.1s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .simon-pad:hover:not(.active):not(:disabled) {
            transform: scale(1.03);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .simon-pad:active:not(.active):not(:disabled) {
            transform: scale(0.97);
        }
        .simon-pad.red { background-color: #e74c3c; } /* Alizarin */
        .simon-pad.green { background-color: #2ecc71; } /* Emerald */
        .simon-pad.blue { background-color: #3498db; } /* Peter River */
        .simon-pad.yellow { background-color: #f1c40f; } /* Sunflower */

        .simon-pad.active {
            opacity: 0.6;
            transform: scale(0.95); /* Slight shrink when active */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }
        .simon-pad:disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }
        #simon-game-container .score-display {
            font-size: 1.3em;
            font-weight: 700;
            color: #4A5568; /* cool-gray-700 */
            margin-bottom: 10px;
        }
        #simon-game-container .score-display strong {
            color: #38A169; /* green-600 */
        }
        #simon-feedback {
            font-size: 1.1em;
            color: #5A67D8; /* indigo-600 */
            font-weight: 600;
            min-height: 1.5em;
            margin-bottom: 15px;
        }

        /* --- ESTILOS PARA JUEGO MEMORIA DE NÚMEROS --- */
        #number-memory-game-container {
            background-color: #f7faff; /* Very light blue */
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 600px;
        }
        #number-memory-game-container .nm-title {
            font-family: 'Fredoka One', cursive;
            color: #805AD5; /* purple-600 */
            font-size: 2em;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px; /* Space for potential icon */
        }
        #number-memory-game-container .nm-subtitle {
            color: #5a677a; /* Mid blue-gray */
            font-size: 1.1em;
            margin-bottom: 20px;
        }
        #number-memory-game-container .nm-game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 12px;
            margin-bottom: 25px;
        }
        #number-memory-game-container .nm-info-card {
            background: #805AD5; /* purple-600 */
            color: white;
            padding: 12px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(128, 90, 213, 0.2); /* Shadow with color tint */
        }
        #number-memory-game-container .nm-info-label {
            font-size: 0.85em;
            opacity: 0.9;
            margin-bottom: 4px;
        }
        #number-memory-game-container .nm-info-value {
            font-size: 1.4em;
            font-weight: bold;
        }
        #number-memory-game-container .nm-difficulty-selector {
            margin: 20px 0;
        }
        #number-memory-game-container .nm-difficulty-selector label {
            color: #4A5568; /* cool-gray-700 */
            font-weight: 600;
            margin-right: 8px;
        }
        #number-memory-game-container .nm-difficulty-selector select {
            padding: 8px 12px;
            border: 2px solid #805AD5; /* purple-600 */
            border-radius: 8px;
            font-size: 1em;
            background: white;
            color: #805AD5; /* purple-600 */
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
        }
        #number-memory-game-container .nm-sequence-display {
            font-size: 1.15em;
            color: #667eea; /* indigo-500 */
            margin: 15px 0;
            font-weight: 600;
            min-height: 1.5em;
        }
        #number-memory-game-container .nm-game-message {
            margin: 15px 0;
            padding: 12px;
            border-radius: 8px;
            font-weight: 600;
            opacity: 0;
            transition: all 0.3s ease;
        }
        #number-memory-game-container .nm-game-message.show {
            opacity: 1;
        }
        #number-memory-game-container .nm-message-success {
            background-color: #C6F6D5; color: #2F855A; border: 1px solid #9AE6B4; /* green */
        }
        #number-memory-game-container .nm-message-info {
            background-color: #EBF4FF; color: #4299E1; border: 1px solid #BEE3F8; /* blue */
        }
        #number-memory-game-container .nm-message-error {
            background-color: #FED7D7; color: #C53030; border: 1px solid #FEB2B2; /* red */
        }
        #number-memory-game-container .nm-game-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* Default, JS might change this */
            gap: 10px;
            margin: 25px auto;
            max-width: 360px; /* Default, JS might change this */
        }
        #number-memory-game-container .nm-number-card {
            aspect-ratio: 1; /* Make cards square */
            background: #667eea; /* indigo-500 */
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1.8em;
            font-weight: bold;
            font-family: 'Fredoka One', cursive;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.25); /* Shadow with color tint */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #number-memory-game-container .nm-number-card:hover:not(:disabled) {
            transform: translateY(-2px);
            background-color: #5a67d8; /* indigo-600 */
        }
        #number-memory-game-container .nm-number-card.flipped {
            background: #A3BFFA; /* indigo-300 */
            color: #2D3748; /* cool-gray-800 */
        }
        #number-memory-game-container .nm-number-card.hidden {
            background: #CBD5E0; /* cool-gray-300 */
            color: transparent;
        }
        #number-memory-game-container .nm-number-card:disabled {
            background: #E2E8F0; /* cool-gray-200 */
            cursor: not-allowed;
            color: #A0AEC0; /* cool-gray-400 */
        }
        #number-memory-game-container .nm-number-card.pulse-effect {
            animation: pulseBlue 0.6s ease-in-out;
            background-color: #4299e1 !important; /* blue-500 */
        }
        @keyframes pulseBlue {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        #number-memory-game-container .nm-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        #number-memory-game-container .nm-btn-primary { background-color: #667eea; /* indigo-500 */ }
        #number-memory-game-container .nm-btn-success { background-color: #48BB78; /* green-500 */ }
        #number-memory-game-container .nm-btn-warning { background-color: #ED8936; /* orange-500 */ }

        /* --- ESTILOS PARA JUEGO LABERINTO DESLIZANTE --- */
        #sliding-puzzle-game-container {
            background-color: #f7faff; /* Very light blue */
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 550px; /* Consistent max-width */
        }
        #sliding-puzzle-game-container .sm-title {
            font-family: 'Fredoka One', cursive;
            color: #B7791F; /* yellow-700 */
            font-size: 2em;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        #sliding-puzzle-game-container .sm-subtitle {
            color: #5a677a; /* Mid blue-gray */
            font-size: 1.1em;
            margin-bottom: 20px;
        }
        #sliding-puzzle-game-container .sm-game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 12px;
            margin-bottom: 25px;
        }
        #sliding-puzzle-game-container .sm-info-card {
            background: #B7791F; /* yellow-700 */
            color: white;
            padding: 12px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(183, 121, 31, 0.2); /* Shadow with color tint */
        }
        #sliding-puzzle-game-container .sm-info-label {
            font-size: 0.85em;
            opacity: 0.9;
            margin-bottom: 4px;
        }
        #sliding-puzzle-game-container .sm-info-value {
            font-size: 1.4em;
            font-weight: bold;
        }
        #sliding-maze-canvas {
            background-color: #edf2f7; /* cool-gray-100 */
            border: 2px solid #CBD5E0; /* cool-gray-300 */
            border-radius: 8px;
            display: block;
            margin: 0 auto 20px auto;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        #sliding-puzzle-game-container .sm-game-message {
            margin: 15px 0;
            padding: 12px;
            border-radius: 8px;
            font-weight: 600;
            opacity: 0;
            transition: all 0.3s ease;
            min-height: 2em; /* Ensure space */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #sliding-puzzle-game-container .sm-game-message.show {
            opacity: 1;
        }
        #sliding-puzzle-game-container .sm-message-success {
            background-color: #C6F6D5; color: #2F855A; border: 1px solid #9AE6B4; /* green */
        }
        #sliding-puzzle-game-container .sm-message-info {
            background-color: #EBF4FF; color: #4299E1; border: 1px solid #BEE3F8; /* blue */
        }
        #sliding-puzzle-game-container .sm-message-error {
            background-color: #FED7D7; color: #C53030; border: 1px solid #FEB2B2; /* red */
        }
        #sliding-puzzle-game-container .sm-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        #sliding-puzzle-game-container .sm-btn-primary { background-color: #B7791F; /* yellow-700 */ }
        #sliding-puzzle-game-container .sm-btn-primary:hover { background-color: #975A16; /* yellow-800 */ }
        #sliding-puzzle-game-container .sm-btn-success { background-color: #48BB78; /* green-500 */ }
        #sliding-puzzle-game-container .sm-btn-success:hover { background-color: #3f9e6a; /* green-600 */ }
        #sliding-puzzle-game-container .sm-btn-warning { background-color: #ED8936; /* orange-500 */ }
        #sliding-puzzle-game-container .sm-btn-warning:hover { background-color: #d57b2f; /* orange-600 */ }


        /* Loot Box, Leaderboard, Medals, Daily Bonus, Notifications, Animaciones */
        .loot-box-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background-color: #fff;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            text-align: center;
            max-width: 380px;
            width: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease-out;
            border: 4px solid #FFD700; /* Gold border */
        }
        .loot-box-container.visible {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }
        .loot-box-container h3 {
            font-family: 'Fredoka One', cursive;
            color: #D4AF37; /* Darker Gold */
            font-size: 2em;
            margin-bottom: 15px;
        }
        .loot-box-icon {
            font-size: 5em; /* For emoji */
            margin-bottom: 15px;
            animation: bounce 1s infinite alternate;
        }
        .loot-box-reward {
            font-size: 1.2em;
            color: #4A5568; /* cool-gray-700 */
            margin-bottom: 25px;
            font-weight: 600;
            min-height: 1.5em;
        }
        .loot-box-container button {
            background-color: #FFD700; /* Gold */
            color: #333; /* Dark text for contrast */
            font-weight: bold;
        }
        .loot-box-container button:hover {
            background-color: #E6B800; /* Darker Gold */
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #333; /* Default dark */
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, transform 0.5s ease;
            transform: translateY(-20px); /* Start off-screen */
            font-size: 0.95em;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            font-weight: 600;
        }
        .notification.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        .notification.success { background-color: #48BB78; /* green-500 */ }
        .notification.error   { background-color: #E53E3E; /* red-600 */ }
        .notification.event   { background-color: #4299E1; /* blue-500 */ }
        .notification.streak  { background-color: #ED8936; /* orange-500 */ }
        .notification.medal   { background-color: #9F7AEA; /* purple-500 */ }


        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes zoomIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        @keyframes pulse { /* For level up */
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(251, 211, 141, 0.7); } /* orange-300 with alpha */
            70% { transform: scale(1.08); box-shadow: 0 0 0 15px rgba(251, 211, 141, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(251, 211, 141, 0); }
        }
        @keyframes pulseRed { /* For timer warning */
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        @keyframes bounce { /* For loot box icon */
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Estilos Responsivos */
        @media (max-width: 700px) {
            .container {
                padding: 20px;
                min-height: auto; /* Allow shrinking */
            }
            .welcome-screen h1, .temporary-welcome-screen h1 { font-size: 2.2em; }
            .selection-screen h2 { font-size: 1.8em; }
            .selection-grid { grid-template-columns: 1fr; } /* Stack cards */

            #math-game-container .problem { font-size: 1.8em; padding: 10px; }
            #math-game-container .input-area { flex-direction: column; }
            #math-game-container input[type="number"] {
                width: 80%;
                max-width: 250px;
                margin: 10px 0;
            }
            #math-game-container .input-area button { margin-left: 0; margin-top: 10px; }

            #mind-twist-game-v2-container .game-title { font-size: 1.8em; }
            #mind-twist-game-v2-container .riddle-text { font-size: 1.1em; }
            #mind-twist-game-v2-container .options-grid { grid-template-columns: 1fr; }
            #mind-twist-game-v2-container .option-button { font-size: 1.1em; }

            #simon-pads-area { width: 180px; height: 180px; gap: 10px;}

            #number-memory-game-container .nm-game-board { max-width: 300px; }
            #number-memory-game-container .nm-number-card { font-size: 1.5em; }
            #sliding-maze-canvas { width: 300px; height: 300px; } /* Adjust canvas size */
        }

        @media (max-width: 480px) {
            body { padding: 10px; }
            .container { padding: 15px; border-radius: 15px; }
            .welcome-screen h1, .temporary-welcome-screen h1 { font-size: 2em; }
            .temporary-welcome-screen p { font-size: 1.1em; }
            .selection-screen h2 { font-size: 1.6em; }
            .selection-screen .game-selection-buttons button {
                min-width: unset;
                width: 90%; /* Full width buttons */
            }
            .game-stats {
                font-size: 0.9em;
                flex-direction: column;
                gap: 5px;
                margin-bottom: 15px;
            }
            .game-stats > div { /* Ensure each stat item takes full width */
                width: 100%;
            }
            #math-game-container .problem { font-size: 1.6em; }
            #math-game-container input[type="number"] { width: 95%; }

            #mind-twist-game-v2-container .game-title { font-size: 1.6em; }
            #mind-twist-game-v2-container .control-button {
                font-size: 0.8em; padding: 8px 12px; margin: 5px;
            }
            #simon-pads-area { width: 150px; height: 150px; }

            #number-memory-game-container .nm-info-card { padding: 8px; font-size: 0.9em; }
            #number-memory-game-container .nm-info-value { font-size: 1.2em; }
            #number-memory-game-container .nm-game-board { max-width: 250px; }
            #number-memory-game-container .nm-number-card { font-size: 1.3em; }
            #sliding-maze-canvas { width: 250px; height: 250px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="welcome-screen" id="welcome-screen">
            <h1>🚀 ¡Desafíos Mentales!</h1>
            <p>Ingresa tus datos para la aventura:</p>
            <input type="text" id="player-name-input" placeholder="Tu Nombre de Campeón" maxlength="20">
            <input type="password" id="player-password-input" placeholder="Contraseña (mín. 4)" maxlength="20">
            <p id="auth-error-message" class="auth-error-message">Error aquí</p>
            <button onclick="handleLoginOrCreate()">Acceder / Crear</button>
        </div>

        <div class="temporary-welcome-screen" id="temporary-welcome-screen">
            <h1 id="temp-welcome-heading">¡Bienvenido/a!</h1>
            <p id="temp-welcome-subtext">Preparando tu aventura...</p>
        </div>

        <div class="selection-screen" id="selection-screen">
            <h2>¡Hola, <span id="display-player-name-selection"></span>!</h2>
            <p class="greeting-subtext">¿Listo para ejercitar tu mente? Elige tu desafío:</p>
            <button class="logout-button" onclick="logout()">Cerrar Sesión</button>

            <div class="game-selection-buttons">
                <button onclick="selectGame('math')"> Mates Rápidas </button>
                <button onclick="selectGame('mindtwist_v2')" class="game-mindtwist"> Acertijos Visuales </button>
                <button onclick="selectGame('simon')" class="game-simon"> Secuencia de Colores </button>
                <button onclick="selectGame('numberMemory')" class="game-number-memory"> Memoria de Números </button>
                <button onclick="selectGame('slidingPuzzle')" class="game-sliding-puzzle"> Laberinto Deslizante </button>
                <button onclick="selectGame('memoryPairs')" class="upcoming"> Parejas de Memoria (Próximamente)</button>
            </div>

            <div class="selection-grid">
                <div class="selection-card" id="player-stats-card">
                    <h3> Tus Estadísticas</h3>
                    <div class="player-stats-summary">
                        <p>Mejor Racha (Mates): <strong id="summary-math-best-streak">0</strong></p>
                        <p>Acertijos V2 Resueltos: <strong id="summary-mindtwist-v2-solved">0</strong></p>
                        <p>Puntuación Máx. (Simón): <strong id="summary-simon-score">0</strong></p>
                        <p>Puntuación Máx. (Mem. Núm.): <strong id="summary-number-memory-score">0</strong></p>
                        <p>Nivel Más Alto (Laberinto): <strong id="summary-sliding-puzzle-highest-level">0</strong></p>
                    </div>
                </div>
                <div class="selection-card" id="leaderboard-card">
                    <h3> Tabla de Posiciones</h3>
                     <p style="font-size:0.85em; text-align:center; margin-bottom:8px;">(Mates / Simón / Mem. Números / Laberinto)</p>
                    <ul class="leaderboard-list" id="leaderboard-list"></ul>
                </div>
                <div class="selection-card" id="medals-card">
                    <h3> Tus Medallas</h3>
                    <div class="medals-list-container">
                        <div class="medals-list" id="medals-list"></div>
                    </div>
                </div>
                 <div class="selection-card daily-bonus-card" id="daily-bonus-card-container" style="display:none;">
                    <h3> Bonificación Diaria</h3>
                    <div class="daily-bonus-container" id="daily-bonus-container">
                        <h4>🎁 ¡Recompensa Especial! 🎁</h4>
                        <p id="daily-bonus-message"></p>
                        <button onclick="collectDailyBonus()">¡Reclamar!</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="math-game-container">
            <div class="game-stats">
                <div class="player-name-display">Jugador: <span id="math-display-player-name"></span></div>
                <div class="lives-display"> Vidas: <span id="math-player-lives">3</span></div>
                <div class="timer-display" id="math-timer-wrapper"> Tiempo: <span id="math-time-left">0</span>s</div>
            </div>
            <div class="level-info">Nivel: <span id="math-current-level">1</span></div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="math-progress-bar-fill">0%</div>
            </div>
            <div class="level-info">Racha Actual: <span id="math-correct-streak">0</span>/<span id="math-correct-per-level-display">5</span> </div>
            <div class="level-info">Mejor Racha: <span id="math-best-streak">0</span> </div>
            <div class="problem" id="math-problem"></div>
            <div class="input-area">
                <input type="number" id="math-user-answer" placeholder="Tu Respuesta" inputmode="numeric">
                <button onclick="checkMathAnswer()">Verificar </button>
            </div>
            <div class="result-area">
                <div class="result" id="math-game-result"></div>
                <div class="explanation" id="math-answer-explanation" style="display: none;"></div>
            </div>
            <button class="back-to-selection-btn" onclick="showScreen('selection')"> Volver a Elegir Juego</button>
        </div>

        <div id="mind-twist-game-v2-container">
            <div class="game-stats">
                <div class="player-name-display">Jugador: <span id="mindtwist-v2-display-player-name"></span></div>
                <div class="timer-display" id="mindtwist-v2-timer-wrapper"> Tiempo: <span id="mindtwist-v2-time-left">0</span>s</div>
            </div>
            <div class="game-title"> Mind Twist - Nivel <span id="mt-v2-level-number">1</span></div>
            <div id="mt-v2-riddle" class="riddle-text">Cargando acertijo...</div>
            <div id="mt-v2-options" class="options-grid"></div>
            <div id="mt-v2-feedback" class="feedback-text"></div>
            <div class="controls-area">
                <button id="mt-v2-hint-btn" class="control-button">💡 Pista</button>
                <button id="mt-v2-pause-btn" class="control-button">⏸️ Pausar</button>
                <button id="mt-v2-next-btn" class="control-button">➡️ Siguiente</button>
            </div>
            <button class="back-to-selection-btn button-style" onclick="showScreen('selection')">↩️ Volver</button>
        </div>

        <div id="simon-game-container">
            <h2> Secuencia de Colores </h2>
            <p class="cognitive-concept">Concepto Cognitivo: Memoria de trabajo, atención y control inhibitorio. Este juego
            desafía tu capacidad para recordar y reproducir secuencias visuales.</p>
            <button id="simon-start-button" onclick="startSimonGame()"> Empezar Juego</button>
            <div id="simon-pads-area">
                <div class="simon-pad red" data-color="red" id="simon-pad-red"></div>
                <div class="simon-pad green" data-color="green" id="simon-pad-green"></div>
                <div class="simon-pad blue" data-color="blue" id="simon-pad-blue"></div>
                <div class="simon-pad yellow" data-color="yellow" id="simon-pad-yellow"></div>
            </div>
            <p class="score-display">Puntuación: <strong id="simon-score">0</strong></p>
            <p id="simon-feedback">¡Presiona "Empezar Juego"!</p>
            <button class="back-to-selection-btn" onclick="showScreen('selection')"> Volver a Elegir Juego</button>
        </div>

        <div id="number-memory-game-container">
            <h2 class="nm-title">🔢 Memoria de Números 🧠</h2>
            <p class="nm-subtitle">¡Memoriza la secuencia y repítela!</p>
            <div class="nm-game-info">
                <div class="nm-info-card">
                    <div class="nm-info-label">Nivel</div>
                    <div class="nm-info-value" id="nm-level">1</div>
                </div>
                <div class="nm-info-card">
                    <div class="nm-info-label">Puntuación</div>
                    <div class="nm-info-value" id="nm-score">0</div>
                </div>
                <div class="nm-info-card">
                    <div class="nm-info-label">Mejor Puntuación</div>
                    <div class="nm-info-value" id="nm-bestScore">0</div>
                </div>
            </div>
            <div class="nm-difficulty-selector">
                <label for="nm-difficulty">Dificultad: </label>
                <select id="nm-difficulty">
                    <option value="easy">Fácil</option>
                    <option value="medium" selected>Medio</option>
                    <option value="hard">Difícil</option>
                    <option value="expert">Experto</option>
                </select>
            </div>
            <div class="nm-sequence-display" id="nm-sequenceDisplay"></div>
            <div class="nm-game-message" id="nm-gameMessage"></div>
            <div class="nm-game-board" id="nm-gameBoard">
                </div>
            <div class="nm-controls">
                <button class="button-style nm-btn nm-btn-primary" id="nm-startBtn">Comenzar</button>
                <button class="button-style nm-btn nm-btn-success" id="nm-showSequenceBtn" style="display: none;">Ver Secuencia</button>
                <button class="button-style nm-btn nm-btn-warning" id="nm-resetBtn">Reiniciar</button>
            </div>
            <button class="back-to-selection-btn button-style" onclick="showScreen('selection')">↩️ Volver</button>
        </div>

        <div id="sliding-puzzle-game-container">
            <h2 class="sm-title">🧩 Laberinto Deslizante 🧭</h2>
            <p class="sm-subtitle">Haz clic en una celda en la fila/columna del espacio ('G') y usa las flechas para deslizarla.</p>
            <div class="sm-game-info">
                <div class="sm-info-card">
                    <div class="sm-info-label">Nivel Actual</div>
                    <div class="sm-info-value" id="sm-level-display">1</div>
                </div>
                <div class="sm-info-card">
                    <div class="sm-info-label">Mejor Nivel</div>
                    <div class="sm-info-value" id="sm-highest-level-display">0</div>
                </div>
            </div>
            <canvas id="sliding-maze-canvas" width="400" height="400"></canvas>
            <div class="sm-game-message" id="sm-gameMessage"></div>
            <div class="sm-controls">
                <button class="button-style sm-btn sm-btn-primary" id="sm-start-btn">Comenzar</button>
                <button class="button-style sm-btn sm-btn-warning" id="sm-reset-btn" style="display:none;">Reiniciar Nivel</button>
                <button class="button-style sm-btn sm-btn-success" id="sm-next-btn" style="display:none;">Siguiente Nivel</button>
            </div>
            <button class="back-to-selection-btn button-style" onclick="showScreen('selection')">↩️ Volver</button>
        </div>


        <div class="loot-box-container" id="loot-box-modal">
            <h3>🎁 ¡Caja de Recompensas! 🎁</h3>
            <div class="loot-box-icon">🎉</div>
            <p class="loot-box-reward" id="loot-box-reward-text">Abriendo...</p>
            <button onclick="closeLootBox()">¡Genial!</button>
        </div>

        <div class="notification" id="notification-display"></div>
    </div>

    <script>
        // --- DOM Elements ---
        const welcomeScreen = document.getElementById('welcome-screen');
        const temporaryWelcomeScreen = document.getElementById('temporary-welcome-screen'); // New
        const tempWelcomeHeading = document.getElementById('temp-welcome-heading'); // New
        const tempWelcomeSubtext = document.getElementById('temp-welcome-subtext'); // New
        const selectionScreen = document.getElementById('selection-screen');
        const mathGameContainer = document.getElementById('math-game-container');
        const mindTwistGameV2Container = document.getElementById('mind-twist-game-v2-container');
        const simonGameContainer = document.getElementById('simon-game-container');
        const numberMemoryGameContainer = document.getElementById('number-memory-game-container');
        const slidingPuzzleGameContainer = document.getElementById('sliding-puzzle-game-container');

        const playerNameInput = document.getElementById('player-name-input');
        const playerPasswordInput = document.getElementById('player-password-input');
        const authErrorMessage = document.getElementById('auth-error-message');
        const displayPlayerNameSelection = document.getElementById('display-player-name-selection');

        // Math Elements
        const mathDisplayPlayerName = document.getElementById('math-display-player-name');
        const mathPlayerLivesDisplay = document.getElementById('math-player-lives');
        const mathTimeLeftDisplay = document.getElementById('math-time-left');
        const mathTimerWrapper = document.getElementById('math-timer-wrapper');
        const mathCurrentLevelDisplay = document.getElementById('math-current-level');
        const mathProgressBarFill = document.getElementById('math-progress-bar-fill');
        const mathCorrectStreakDisplay = document.getElementById('math-correct-streak');
        const mathCorrectPerLevelDisplay = document.getElementById('math-correct-per-level-display');
        const mathBestStreakDisplay = document.getElementById('math-best-streak');
        const mathProblemDisplay = document.getElementById('math-problem');
        const mathUserAnswerInput = document.getElementById('math-user-answer');
        const mathGameResultDisplay = document.getElementById('math-game-result');
        const mathAnswerExplanationDisplay = document.getElementById('math-answer-explanation');

        // Mind Twist V2 Elements
        const mindtwistV2DisplayPlayerName = document.getElementById('mindtwist-v2-display-player-name');
        const mindtwistV2TimeLeftDisplay = document.getElementById('mindtwist-v2-time-left');
        const mindtwistV2TimerWrapper = document.getElementById('mindtwist-v2-timer-wrapper');
        const mtV2LevelNumber = document.getElementById("mt-v2-level-number");
        const mtV2RiddleText = document.getElementById("mt-v2-riddle");
        const mtV2OptionsContainer = document.getElementById("mt-v2-options");
        const mtV2Feedback = document.getElementById("mt-v2-feedback");
        const mtV2HintBtn = document.getElementById("mt-v2-hint-btn");
        const mtV2PauseBtn = document.getElementById("mt-v2-pause-btn");
        const mtV2NextBtn = document.getElementById("mt-v2-next-btn");

        // Simon Elements
        const simonStartButton = document.getElementById('simon-start-button');
        const simonPadElements = {
            red: document.getElementById('simon-pad-red'),
            green: document.getElementById('simon-pad-green'),
            blue: document.getElementById('simon-pad-blue'),
            yellow: document.getElementById('simon-pad-yellow')
        };
        const simonScoreDisplay = document.getElementById('simon-score');
        const simonFeedbackDisplay = document.getElementById('simon-feedback');

        // Number Memory Elements
        let nmGameInstance = null;
        const nmLevelDisplayElem = document.getElementById('nm-level');
        const nmScoreDisplayElem = document.getElementById('nm-score');
        const nmBestScoreDisplayElem = document.getElementById('nm-bestScore');
        const nmStartBtn = document.getElementById('nm-startBtn');
        const nmShowSequenceBtn = document.getElementById('nm-showSequenceBtn');
        const nmResetBtn = document.getElementById('nm-resetBtn');
        const nmGameMessageElem = document.getElementById('nm-gameMessage');
        const nmDifficultySelect = document.getElementById('nm-difficulty');
        const nmSequenceDisplayElem = document.getElementById('nm-sequenceDisplay');
        const nmGameBoardElem = document.getElementById('nm-gameBoard');

        // Sliding Puzzle Elements
        let smGameInstance = null;
        const smCanvas = document.getElementById('sliding-maze-canvas');
        const smCtx = smCanvas.getContext('2d');
        const smLevelDisplay = document.getElementById('sm-level-display');
        const smHighestLevelDisplay = document.getElementById('sm-highest-level-display');
        const smGameMessageElem = document.getElementById('sm-gameMessage');
        const smStartBtn = document.getElementById('sm-start-btn');
        const smResetBtn = document.getElementById('sm-reset-btn');
        const smNextBtn = document.getElementById('sm-next-btn');


        // Summary Stats Elements
        const summaryMathBestStreak = document.getElementById('summary-math-best-streak');
        const summaryMindtwistV2Solved = document.getElementById('summary-mindtwist-v2-solved');
        const summarySimonScore = document.getElementById('summary-simon-score');
        const summaryNumberMemoryScore = document.getElementById('summary-number-memory-score');
        const summarySlidingPuzzleHighestLevel = document.getElementById('summary-sliding-puzzle-highest-level');

        // UI Global Elements
        const lootBoxModal = document.getElementById('loot-box-modal');
        const lootBoxRewardText = document.getElementById('loot-box-reward-text');
        const notificationDisplay = document.getElementById('notification-display');
        const leaderboardList = document.getElementById('leaderboard-list');
        const medalsList = document.getElementById('medals-list');
        const dailyBonusContainer = document.getElementById('daily-bonus-container');
        const dailyBonusCardContainer = document.getElementById('daily-bonus-card-container');
        const dailyBonusMessage = document.getElementById('daily-bonus-message');


        // --- Game State & Config ---
        let currentLoggedInPlayer = null;
        let allUsersData = {}; // { username: { password: "...", stats: {...} } }

        const defaultPlayerStats = () => ({
            math: { currentLevel: 1, correctStreak: 0, bestStreak: 0, playerLives: 3, totalCorrect: 0, totalIncorrect: 0, totalGamesPlayed: 0, questionsInLevel: 0 },
            mindtwistV2: { currentLevel: 0, highestLevelReached: 0, hintsUsed: 0, solvedCount: 0, totalAttempts: 0 },
            simon: { highestScore: 0, longestSequence: 0, totalGamesPlayed: 0 },
            numberMemory: { highestScore: 0, highestLevelReached: 0, gamesPlayed: 0, currentDifficulty: 'medium', maxLevel: 20 }, // maxLevel for this game
            slidingPuzzle: { currentLevel: 0, highestLevelReached: 0, totalGamesPlayed: 0 },
            inventory: [], // e.g., ["bonus_racha_mates", "bonus_tiempo_inicio_mates"]
            medals: [], // e.g., ["first_game", "math_streak_5"]
            lastPlayed: null, // Date string or timestamp
            lastBonusCollectedDate: null, // Stores YYYY-MM-DD of last bonus collection
            lastLoginDate: null, // Stores YYYY-MM-DD of last login
            loginHistory: [] // Stores YYYY-MM-DD of unique login days
        });

        let activeGame = null; // 'math', 'mindtwist_v2', 'simon', 'numberMemory', 'slidingPuzzle'

        // Math
        const MATH_CORRECT_PER_LEVEL = 5;
        const MATH_MAX_LEVEL = 20;
        const INITIAL_LIVES = 3;
        let mathCorrectAnswer;
        let mathTimerId = null;
        let mathTimeLeft = 0;
        const MATH_BASE_TIME_PER_QUESTION = 15; // seconds
        const MATH_TIME_REDUCTION_PER_LEVEL = 0.5; // seconds
        const MATH_MIN_TIME_PER_QUESTION = 5; // seconds

        // MindTwist V2
        let mtV2_paused = false;
        let mtV2_timerId = null;
        let mtV2_timeLeft = 0;
        const MT_V2_BASE_TIME_PER_LEVEL = 30; // seconds
        const MT_V2_TIME_INCREMENT_CORRECT = 5; // seconds
        const mindTwistV2Levels = [
            // Emojis como opciones visuales (idealmente serían imágenes o SVGs)
            { riddle: "¿Cuál figura no encaja?", options: ["🟥", "🔵", "🟢", "🟧"], answer: 3, hint: "Una de las figuras tiene un color diferente a los primarios/secundarios comunes." },
            { riddle: "¿Cuál número sigue? 2, 4, 8, 16, ?", options: ["18", "32", "24", "20"], answer: 1, hint: "Piensa en multiplicaciones por 2." },
            { riddle: "¿Qué letra falta? A, C, E, G, ?", options: ["I", "H", "J", "K"], answer: 0, hint: "Cada letra salta una del abecedario." },
            { riddle: "¿Qué figura es simétrica verticalmente?", options: ["🔷", "🔶", "💠", "🔺"], answer: 2, hint: "Piensa en reflejo de espejo vertical. (💠 es simétrica)" },
            { riddle: "¿Qué objeto pesa más?", options: ["깃털 (Pluma) 🪶", "벽돌 (Ladrillo)🧱", "종이 (Papel)📄", "솜 (Algodón)☁️"], answer: 1, hint: "Compara materiales. (Emojis por diversión)" },
            { riddle: "¿Qué sombra corresponde al objeto 🌳?", options: ["🌲", "🌴", "🌳", "🌵"], answer: 2, hint: "Busca la forma exacta de la sombra, no un árbol similar." },
            { riddle: "¿Qué imagen no tiene simetría?", options: ["🦋", "⭐", "❤️", "🐌"], answer: 3, hint: "Observa si puedes dividirla en mitades iguales." },
            { riddle: "¿Cuál figura rota 90° (horario) sigue? ➡️", options: ["⬇️", "⬆️", "⬅️", "🔄"], answer: 0, hint: "Rotación en sentido horario." },
            { riddle: "¿Qué número falta? 1, 3, 6, 10, ?", options: ["12", "14", "15", "16"], answer: 2, hint: "Suma consecutiva: +2, +3, +4..." },
            { riddle: "¿Cuál figura es diferente por cantidad de lados?", options: ["📐", "⭕", "◻️", "🔺"], answer: 1, hint: "Piensa en lados y curvas." }
        ];


        // Simon
        let simonGameActive = false;
        let simonSequence = [];
        let simonPlayerSequence = [];
        let simonCurrentScore = 0;
        let simonTurn = 'computer'; // 'computer' or 'player'
        const SIMON_COLORS = ['red', 'green', 'blue', 'yellow'];
        const SIMON_FLASH_DURATION = 300; // ms
        const SIMON_INTER_FLASH_DELAY = 250; // ms
        const SIMON_ROUND_DELAY = 1000; // ms

        // Loot Box & Medals
        const MATH_GAME_LOOT_BOX_PROBABILITY = 0.25; // 25% chance
        const MINDTWIST_V2_LOOT_BOX_PROBABILITY = 0.20; // 20%
        const SIMON_LOOT_BOX_PROBABILITY = 0.20; // 20%
        const NUMBER_MEMORY_LOOT_BOX_PROBABILITY = 0.18; // 18%
        const SLIDING_PUZZLE_LOOT_BOX_PROBABILITY = 0.15; // 15%

        const MEDALS = [
            { id: "first_game", name: "Primer Juego", description: "Juega tu primera partida de cualquier juego.", icon: "🎮", condition: (stats) => stats.math.totalGamesPlayed > 0 || stats.mindtwistV2.totalAttempts > 0 || stats.simon.totalGamesPlayed > 0 || stats.numberMemory.gamesPlayed > 0 || stats.slidingPuzzle.totalGamesPlayed > 0 },
            { id: "math_first_correct", name: "Matiniciante", description: "Resuelve tu primer problema de Mates Rápidas.", icon: "➕", condition: (stats) => stats.math.totalCorrect > 0 && stats.math.totalGamesPlayed > 0 },
            { id: "mindtwist_v2_first_try", name: "Explorador V2", description: "Intenta resolver tu primer acertijo visual V2.", icon: "🤔", condition: (stats) => stats.mindtwistV2.totalAttempts > 0 },
            { id: "mindtwist_v2_solved_1", name: "Acertijo V2 Resuelto", description: "Resuelve tu primer acertijo visual V2.", icon: "💡", condition: (stats) => stats.mindtwistV2.solvedCount >= 1 },
            { id: "simon_first_game", name: "Maestro Simón Jr.", description: "Juega tu primera partida de Secuencia de Colores.", icon: "🎨", condition: (stats) => stats.simon.totalGamesPlayed > 0 },
            { id: "nm_first_game", name: "Numerólogo Inicial", description: "Juega tu primera partida de Memoria de Números.", icon: "🧠", condition: (stats) => stats.numberMemory.gamesPlayed > 0 },
            { id: "nm_score_100", name: "Cien Puntos Numéricos", description: "Alcanza 100 puntos en Memoria de Números.", icon: "💯", condition: (stats) => stats.numberMemory.highestScore >= 100 },
            { id: "sm_first_level", name: "Primer Deslizamiento", description: "Completa el primer nivel del Laberinto Deslizante.", icon: "➡️", condition: (stats) => stats.slidingPuzzle.highestLevelReached >= 1 },
            { id: "sm_level_3", name: "Dominio de Laberinto", description: "Alcanza el nivel 3 en Laberinto Deslizante.", icon: "🏆", condition: (stats) => stats.slidingPuzzle.highestLevelReached >= 3 },
            { id: "math_streak_5", name: "Racha de 5 (Mates)", description: "Logra una racha de 5 respuestas correctas en Mates Rápidas.", icon: "🔥", condition: (stats) => stats.math.bestStreak >= 5 },
            { id: "math_level_5", name: "Nivel 5 (Mates)", description: "Alcanza el nivel 5 en Mates Rápidas.", icon: "⭐", condition: (stats) => stats.math.currentLevel >= 5 },
            { id: "math_level_10", name: "Nivel 10 (Mates)", description: "Alcanza el nivel 10 en Mates Rápidas.", icon: "🌟", condition: (stats) => stats.math.currentLevel >= 10 },
            { id: "simon_score_50", name: "Simón Puntuador", description: "Alcanza 50 puntos en Secuencia de Colores.", icon: "🎯", condition: (stats) => stats.simon.highestScore >= 50 },
            { id: "simon_sequence_5", name: "Memoria Prodigiosa", description: "Repite una secuencia de 5 colores en Simón.", icon: "🧠", condition: (stats) => stats.simon.longestSequence >= 5 },
            { id: "daily_login_3", name: "Visitante Frecuente", description: "Inicia sesión 3 días diferentes.", icon: "📅", condition: (stats) => countUniqueLoginDays(stats) >= 3 }
        ];
        let mathCurrentProblemDetails = {}; // { num1, num2, operator }

        // --- Audio ---
        let synthsInitialized = false;
        let correctSound, incorrectSound, levelUpSound, gameStartSound, levelDownSound, lifeLostSound,
            mindTwistV2CorrectSound, mindTwistV2IncorrectSound, lootBoxSound, dailyBonusSound, medalSound, clickSound, timerTickSound,
            simonPadSounds = {}, nmCardClickSound, nmSequenceHighlightSound, nmErrorSound;
        let smSlideSound, smWinSound, smLoseSound, smClickSound; // Sliding Maze sounds

        async function initializeAudio() {
            if (synthsInitialized || (typeof Tone === 'undefined') || (Tone.context && Tone.context.state === 'running')) {
                return;
            }
            try {
                await Tone.start(); // Required for user gesture
                console.log("AudioContext started successfully!");

                correctSound = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 } }).toDestination();
                incorrectSound = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.02, decay: 0.2, sustain: 0, release: 0.2 }, volume: -10 }).toDestination();
                levelUpSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.5 }, volume: -5 }).toDestination();
                gameStartSound = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.1, release: 0.5 }, volume: -8 }).toDestination();
                levelDownSound = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.1, release: 0.3 }, volume: -10 }).toDestination();
                lifeLostSound = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 }, volume: -12 }).toDestination();
                mindTwistV2CorrectSound = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 }, volume: -15 }).toDestination();
                mindTwistV2IncorrectSound = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.02, decay: 0.2, sustain: 0, release: 0.2 }, volume: -18 }).toDestination();
                lootBoxSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.05, decay: 0.4, sustain: 0.1, release: 0.5 }, volume: -7 }).toDestination();
                dailyBonusSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sine" }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.1, release: 0.5 }, volume: -6 }).toDestination();
                medalSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "square" }, envelope: { attack: 0.02, decay: 0.3, sustain: 0.1, release: 0.4 }, volume: -8 }).toDestination();
                clickSound = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 2, envelope: { attack: 0.0006, decay: 0.2, sustain: 0 } }).toDestination();
                timerTickSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 1.5, envelope: { attack: 0.001, decay: 0.1, sustain: 0 }, volume: -25 }).toDestination();

                simonPadSounds.red = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 }, volume: -12 }).toDestination();
                simonPadSounds.green = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 }, volume: -12 }).toDestination();
                simonPadSounds.blue = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 }, volume: -12 }).toDestination();
                simonPadSounds.yellow = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 }, volume: -12 }).toDestination();

                nmCardClickSound = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 }, volume: -18 }).toDestination();
                nmSequenceHighlightSound = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.02, release: 0.1 }, volume: -15 }).toDestination();
                nmErrorSound = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }, volume: -15 }).toDestination();

                smSlideSound = new Tone.PluckSynth({ attackNoise: 0.8, dampening: 4000, resonance: 0.9, volume: -10 }).toDestination();
                smWinSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.05, decay: 0.4, sustain: 0.1, release: 0.5 }, volume: -7 }).toDestination();
                smLoseSound = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.05, decay: 0.3, sustain: 0, release: 0.3 }, volume: -10 }).toDestination();
                smClickSound = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 2, envelope: { attack: 0.0006, decay: 0.2, sustain: 0 }, volume: -15 }).toDestination();

                synthsInitialized = true;
            } catch (e) {
                console.error("Error initializing AudioContext or synths:", e);
            }
        }

        const congratulations = [
            "¡Bien hecho, {name}! ¡Nivel {level} desbloqueado!",
            "¡Excelente trabajo! ¡Pasaste al Nivel {level}!",
            "¡Fantástico, {name}! ¡Ya estás en el Nivel {level}!",
            "¡Increíble! ¡El Nivel {level} te espera, {name}!",
            "¡Sigue así, {name}! ¡Nivel {level} superado con éxito!",
            "¡Eres una estrella, {name}! ¡Bienvenido al Nivel {level}!",
            "¡Lo lograste, {name}! ¡A conquistar el Nivel {level}!"
        ];


        // --- Core & Utility Functions ---
        function getUserStats() {
            return currentLoggedInPlayer && allUsersData[currentLoggedInPlayer] ? allUsersData[currentLoggedInPlayer].stats : null;
        }

        function countUniqueLoginDays(stats) {
            if (!stats || !stats.loginHistory) return 0;
            const uniqueDays = new Set(stats.loginHistory);
            return uniqueDays.size;
        }


        function playSound(sound, note, duration = '8n', timeOffset = '+0') {
            if (synthsInitialized && sound && Tone.context && Tone.context.state === 'running') {
                try {
                    const time = Tone.now() + parseFloat(timeOffset.replace('+', ''));
                    if (sound instanceof Tone.PolySynth) {
                        sound.triggerAttackRelease(note, duration, time);
                    } else if (sound instanceof Tone.NoiseSynth || sound instanceof Tone.MembraneSynth || sound instanceof Tone.PluckSynth) {
                        sound.triggerAttackRelease(duration, time); // These synths might not take a note or a different signature
                    } else { // Assuming Tone.Synth
                        sound.triggerAttackRelease(note, duration, time);
                    }
                } catch (e) {
                    console.error("Error playing sound:", e, {sound, note, duration, timeOffset});
                }
            }
        }
        function playClickSound() {
            if (synthsInitialized && clickSound) playSound(clickSound, null, '16n');
        }


        function showScreen(screenId) {
            playClickSound();
            // Hide all screens first
            [welcomeScreen, temporaryWelcomeScreen, selectionScreen, mathGameContainer, mindTwistGameV2Container, simonGameContainer, numberMemoryGameContainer, slidingPuzzleGameContainer].forEach(el => {
                if (el) el.style.display = 'none';
            });

            // Stop any active game timers or processes
            if (activeGame === 'math') clearTimeout(mathTimerId);
            else if (activeGame === 'mindtwist_v2') { clearTimeout(mtV2_timerId); mtV2_paused = false; }
            else if (activeGame === 'simon' && simonGameActive) { simonGameActive = false; simonStartButton.disabled = false; Object.values(simonPadElements).forEach(pad => pad.disabled = true); }
            else if (activeGame === 'numberMemory' && nmGameInstance && nmGameInstance.gameActive) nmGameInstance.pauseGameForScreenChange();
            else if (activeGame === 'slidingPuzzle' && smGameInstance && smGameInstance.gameActive) smGameInstance.pauseGameForScreenChange();


            let targetScreen;
            if (screenId === 'welcome') {
                targetScreen = welcomeScreen;
                playerNameInput.value = ''; playerPasswordInput.value = ''; // Clear inputs
                authErrorMessage.style.display = 'none'; // Hide error message
            } else if (screenId === 'temporary_welcome') { // New screen case
                targetScreen = temporaryWelcomeScreen;
            } else if (screenId === 'selection') {
                if (!currentLoggedInPlayer) { showScreen('welcome'); return; } // Redirect to welcome if not logged in
                updateSelectionScreenStats();
                checkDailyBonus();
                updateMedalsDisplay();
                updateLeaderboardDisplay();
                targetScreen = selectionScreen;
            } else if (screenId === 'math') targetScreen = mathGameContainer;
            else if (screenId === 'mindtwist_v2') targetScreen = mindTwistGameV2Container;
            else if (screenId === 'simon') targetScreen = simonGameContainer;
            else if (screenId === 'numberMemory') targetScreen = numberMemoryGameContainer;
            else if (screenId === 'slidingPuzzle') targetScreen = slidingPuzzleGameContainer;


            if (targetScreen) targetScreen.style.display = 'flex'; // Show the target screen
            activeGame = screenId; // Update the active game/screen
        }

        // --- Auth & User ---
        function handleLoginOrCreate() {
            initializeAudio(); // Ensure audio context is ready
            playClickSound();
            const username = playerNameInput.value.trim();
            const password = playerPasswordInput.value;
            authErrorMessage.style.display = 'none'; // Reset error message

            if (!username) { authErrorMessage.textContent = '¡Tu nombre es esencial!'; authErrorMessage.style.display = 'block'; return; }
            if (username.length > 20) { authErrorMessage.textContent = 'Nombre demasiado largo (Máx. 20).'; authErrorMessage.style.display = 'block'; return; }
            if (!password) { authErrorMessage.textContent = 'Contraseña requerida.'; authErrorMessage.style.display = 'block'; return; }
            if (password.length < 4) { authErrorMessage.textContent = 'Contraseña muy corta (Mín. 4).'; authErrorMessage.style.display = 'block'; return; }

            let isNewUser = false;
            if (allUsersData[username]) { // Existing user
                if (allUsersData[username].password === password) {
                    currentLoggedInPlayer = username;
                } else {
                    authErrorMessage.textContent = 'Contraseña incorrecta.';
                    authErrorMessage.style.display = 'block';
                    return;
                }
            } else { // New user
                allUsersData[username] = { password: password, stats: defaultPlayerStats() };
                currentLoggedInPlayer = username;
                isNewUser = true;
            }

            // Update player name displays
            displayPlayerNameSelection.textContent = currentLoggedInPlayer;
            mathDisplayPlayerName.textContent = currentLoggedInPlayer;
            mindtwistV2DisplayPlayerName.textContent = currentLoggedInPlayer;
            // Add for other games if they have a name display

            const todayStr = new Date().toISOString().split('T')[0];
            const userStats = getUserStats();
            if (userStats) {
                // Update last login date and history
                if (!userStats.lastLoginDate || userStats.lastLoginDate !== todayStr) {
                    userStats.lastLoginDate = todayStr;
                    if (!userStats.loginHistory.includes(todayStr)) {
                        userStats.loginHistory.push(todayStr);
                        if (userStats.loginHistory.length > 30) userStats.loginHistory.shift(); // Keep last 30 unique days
                    }
                }
            }


            saveAllUsersData();

            // Show temporary welcome message
            tempWelcomeHeading.textContent = `¡Hola, ${currentLoggedInPlayer}!`;
            tempWelcomeSubtext.textContent = isNewUser ? "¡Cuenta creada con éxito! Preparando tu aventura..." : "¡Bienvenido/a de nuevo! Cargando tus desafíos...";
            showScreen('temporary_welcome');

            setTimeout(() => {
                showScreen('selection');
                if (userStats) checkAndAwardMedal("first_game"); // Check medal after reaching selection
            }, 2500); // Show welcome for 2.5 seconds
        }

        function logout() {
            playClickSound();
            if (currentLoggedInPlayer) {
                showNotification(`¡Hasta pronto, ${currentLoggedInPlayer}!`, 'event');
                saveAllUsersData(); // Save any last-minute changes before logging out
                currentLoggedInPlayer = null;
            }
            showScreen('welcome');
        }

        // --- Game Selection ---
        function selectGame(gameType) {
            playClickSound();
            if (!currentLoggedInPlayer) { showScreen('welcome'); return; }

            if (gameType === 'math') { startMathGame(); showScreen('math'); }
            else if (gameType === 'mindtwist_v2') { startMindTwistGameV2(); showScreen('mindtwist_v2'); }
            else if (gameType === 'simon') { startSimonGame(); showScreen('simon');}
            else if (gameType === 'numberMemory') { startNumberMemoryGame(); showScreen('numberMemory'); }
            else if (gameType === 'slidingPuzzle') { startSlidingMazeGame(); showScreen('slidingPuzzle');}
            else if (gameType === 'memoryPairs') { showNotification("Parejas de Memoria - ¡Próximamente!", "event"); }
        }

        // --- UI Updates ---
        function updateSelectionScreenStats() {
            const userStats = getUserStats();
            if (!userStats) return;

            summaryMathBestStreak.textContent = userStats.math.bestStreak;
            summaryMindtwistV2Solved.textContent = userStats.mindtwistV2.solvedCount;
            summarySimonScore.textContent = userStats.simon.highestScore;
            summaryNumberMemoryScore.textContent = userStats.numberMemory.highestScore;
            summarySlidingPuzzleHighestLevel.textContent = userStats.slidingPuzzle.highestLevelReached;
        }


        // --- Math Game Logic ---
        function startMathGame() {
            const userStats = getUserStats();
            if (!userStats) return;
            playSound(gameStartSound, 'C4', '0.5s');

            userStats.math.currentLevel = userStats.math.currentLevel > 0 ? userStats.math.currentLevel : 1; // Ensure level is at least 1
            userStats.math.playerLives = INITIAL_LIVES;
            userStats.math.correctStreak = 0;
            userStats.math.questionsInLevel = 0; // Reset questions for current level progress

            // Check for "bonus_racha_mates" in inventory
            const rachaBonusIndex = userStats.inventory.indexOf("bonus_racha_mates");
            if (rachaBonusIndex > -1) {
                userStats.math.correctStreak = 1; // Start with a streak of 1
                userStats.inventory.splice(rachaBonusIndex, 1); // Remove bonus from inventory
                showNotification("¡Bonus de racha inicial aplicado!", "event", 2000);
            }

            updateMathGameDisplay();
            nextMathProblem();
            userStats.math.totalGamesPlayed++;
            saveAllUsersData();
            checkAndAwardMedal("first_game");
        }

        function getMathTimeForCurrentLevel() {
            const userStats = getUserStats();
            if (!userStats) return MATH_BASE_TIME_PER_QUESTION;

            let time = MATH_BASE_TIME_PER_QUESTION - (userStats.math.currentLevel - 1) * MATH_TIME_REDUCTION_PER_LEVEL;
            time = Math.max(time, MATH_MIN_TIME_PER_QUESTION);

            // Check for "bonus_tiempo_inicio_mates" only at the start of the first question of a level
            if (userStats.math.questionsInLevel === 0) { // Only for the first question of the current attempt at this level
                const tiempoBonusIndex = userStats.inventory.indexOf("bonus_tiempo_inicio_mates");
                if (tiempoBonusIndex > -1) {
                    time += 5; // Add 5 seconds bonus
                    userStats.inventory.splice(tiempoBonusIndex, 1); // Remove bonus
                    showNotification("¡+5s de bonus de tiempo inicial!", "event", 2000);
                }
            }
            return time;
        }


        function nextMathProblem() {
            const userStats = getUserStats();
            if (!userStats || userStats.math.playerLives <= 0) {
                gameOverMath();
                return;
            }
            clearTimeout(mathTimerId);
            mathTimeLeft = getMathTimeForCurrentLevel();

            mathUserAnswerInput.value = '';
            mathUserAnswerInput.focus();
            mathAnswerExplanationDisplay.style.display = 'none'; // Hide previous explanation
            mathGameResultDisplay.textContent = ''; // Clear previous result
            mathGameResultDisplay.className = 'result'; // Reset result class
            mathTimerWrapper.classList.remove('text-red-500'); // Reset timer color

            generateMathProblem();
            updateMathGameDisplay();
            mathTimerId = setInterval(updateMathTimer, 1000);
        }

        function generateMathProblem() {
            const userStats = getUserStats();
            if (!userStats) return;
            const level = userStats.math.currentLevel;
            let num1, num2, operator, problemText;

            if (level <= 3) { // Suma y resta simple
                operator = Math.random() < 0.5 ? '+' : '-';
                num1 = Math.floor(Math.random() * 10) + 1;
                num2 = Math.floor(Math.random() * 10) + 1;
                if (operator === '-' && num1 < num2) [num1, num2] = [num2, num1]; // Evitar negativos
            } else if (level <= 7) { // Suma, resta, multiplicación básica
                const r = Math.random();
                operator = r < 0.4 ? '+' : (r < 0.8 ? '-' : '*');
                if (operator === '*') {
                    num1 = Math.floor(Math.random() * 9) + 2; // Max 10*10
                    num2 = Math.floor(Math.random() * 9) + 2;
                } else {
                    num1 = Math.floor(Math.random() * 20 * (level / 3)) + 1;
                    num2 = Math.floor(Math.random() * 20 * (level / 3)) + 1;
                    if (operator === '-' && num1 < num2) [num1, num2] = [num2, num1];
                }
            } else if (level <= 12) { // Suma, resta, multi, división exacta
                const r = Math.random();
                operator = r < 0.3 ? '+' : (r < 0.5 ? '-' : (r < 0.85 ? '*' : '/'));
                if (operator === '*') {
                    num1 = Math.floor(Math.random() * 10) + 5; // Max 15*15
                    num2 = Math.floor(Math.random() * 10) + (level > 9 ? 5 : 2);
                } else if (operator === '/') {
                    num2 = Math.floor(Math.random() * 8) + 2; // Divisor
                    mathCorrectAnswer = Math.floor(Math.random() * 8) + 2; // Resultado
                    num1 = num2 * mathCorrectAnswer; // Dividendo
                } else {
                    num1 = Math.floor(Math.random() * 50 * (level / 6)) + 10;
                    num2 = Math.floor(Math.random() * 50 * (level / 6)) + 10;
                    if (operator === '-' && num1 < num2) [num1, num2] = [num2, num1];
                }
            } else { // Más difícil: Multiplicaciones mayores, divisiones, sumas/restas con números más grandes
                const r = Math.random();
                operator = r < 0.4 ? '*' : (r < 0.7 ? '/' : (Math.random() < 0.5 ? '+' : '-')); // Added more + and -
                if (operator === '*') {
                    num1 = Math.floor(Math.random() * 15) + 5; // Max 20*20
                    num2 = Math.floor(Math.random() * 15) + 5;
                } else if (operator === '/') {
                    num2 = Math.floor(Math.random() * 10) + 2;
                    mathCorrectAnswer = Math.floor(Math.random() * 12) + 2;
                    num1 = num2 * mathCorrectAnswer;
                } else { // + or -
                    num1 = Math.floor(Math.random() * (50 + level * 5)) + 20;
                    num2 = Math.floor(Math.random() * (50 + level * 5)) + 20;
                    if (operator === '-' && num1 < num2) [num1, num2] = [num2, num1];
                }
            }

            if (operator !== '/') { // Calculate answer if not division (already calculated for exact division)
                switch (operator) {
                    case '+': mathCorrectAnswer = num1 + num2; break;
                    case '-': mathCorrectAnswer = num1 - num2; break;
                    case '*': mathCorrectAnswer = num1 * num2; break;
                }
            }
            mathCurrentProblemDetails = { num1, num2, operator };
            problemText = `<span>${num1}</span> <span style="color: #667eea;">${operator}</span> <span>${num2}</span> = ?`;
            mathProblemDisplay.innerHTML = problemText;
        }

        function checkMathAnswer() {
            const userStats = getUserStats();
            if (!userStats) return;
            clearTimeout(mathTimerId);
            const userAnswer = parseInt(mathUserAnswerInput.value);

            if (isNaN(userAnswer)) {
                showMathResult("¡Ingresa un número!", "incorrect");
                userStats.math.playerLives--;
                playSound(lifeLostSound, 'C3', '0.1s');
                updateMathGameDisplay(); // Update lives display
                setTimeout(nextMathProblem, 1500);
                return;
            }

            if (userAnswer === mathCorrectAnswer) {
                userStats.math.correctStreak++;
                userStats.math.questionsInLevel++;
                userStats.math.totalCorrect++;
                if (userStats.math.correctStreak > userStats.math.bestStreak) {
                    userStats.math.bestStreak = userStats.math.correctStreak;
                    showNotification(`¡Nueva mejor racha: ${userStats.math.bestStreak}!`, "streak", 2500);
                    addToLeaderboard(currentLoggedInPlayer, userStats.math.bestStreak, 'math');
                }
                showMathResult("¡Correcto! ", "correct");
                playSound(correctSound, 'C5', '0.1s');
                checkAndAwardMedal("math_first_correct");

                if (userStats.math.questionsInLevel >= MATH_CORRECT_PER_LEVEL) {
                    levelUpMath();
                } else {
                    updateMathGameDisplay();
                    setTimeout(nextMathProblem, 1000);
                }
            } else {
                userStats.math.playerLives--;
                userStats.math.correctStreak = 0; // Reset streak
                userStats.math.totalIncorrect++;
                showMathResult(`Incorrecto. La respuesta era ${mathCorrectAnswer}. `, "incorrect");
                showMathExplanation();
                playSound(incorrectSound, 'C3', '0.2s');
                playSound(lifeLostSound, 'A2', '0.1s', '+0.1'); // Slightly delayed life lost sound

                updateMathGameDisplay();
                if (userStats.math.playerLives <= 0) {
                    setTimeout(gameOverMath, 2000); // Delay before game over screen
                } else {
                    setTimeout(nextMathProblem, 2500); // Longer delay for incorrect answer
                }
            }

            checkAndAwardAllMedals(); // Check all medals after an answer
            saveAllUsersData();
        }

        function showMathExplanation() {
            const { num1, num2, operator } = mathCurrentProblemDetails;
            let explanation = `<strong>Explicación:</strong> `;
            switch (operator) {
                case '+': explanation += `Sumar ${num1} y ${num2} da como resultado <code>${num1} + ${num2} = ${mathCorrectAnswer}</code>.`; break;
                case '-': explanation += `Restar ${num2} de ${num1} da como resultado <code>${num1} - ${num2} = ${mathCorrectAnswer}</code>.`; break;
                case '*': explanation += `Multiplicar ${num1} por ${num2} da como resultado <code>${num1} * ${num2} = ${mathCorrectAnswer}</code>.`; break;
                case '/': explanation += `Dividir ${num1} entre ${num2} da como resultado <code>${num1} / ${num2} = ${mathCorrectAnswer}</code>. (Porque ${num2} * ${mathCorrectAnswer} = ${num1}).`; break;
            }
            mathAnswerExplanationDisplay.innerHTML = explanation;
            mathAnswerExplanationDisplay.style.display = 'block';
        }


        function levelUpMath() {
            const userStats = getUserStats();
            if (!userStats) return;

            userStats.math.currentLevel++;
            userStats.math.questionsInLevel = 0; // Reset for new level
            userStats.math.correctStreak = 0; // Reset streak for new level (optional, could carry over)
            showMathResult(getCongratulationsMessage(), "level-up", 2500);
            playSound(levelUpSound, ['C4', 'E4', 'G4', 'C5'], '0.5s');

            if (userStats.math.currentLevel > MATH_MAX_LEVEL) {
                showMathResult("¡Has dominado Mates Rápidas! ", "correct", 3000);
                setTimeout(() => showScreen('selection'), 3000);
                return;
            }

            // Award a life if not at max lives (e.g., max 5 lives)
            if (userStats.math.playerLives < INITIAL_LIVES + 2) { // Example: max 5 lives
                userStats.math.playerLives++;
                showNotification("+1 Vida por subir de nivel! ", "event", 1500);
            }

            updateMathGameDisplay();
            setTimeout(nextMathProblem, 2500); // Delay before next problem
            checkAndAwardAllMedals(); // Check medals on level up
        }

        function levelDownMath() { // Called when game over and level > 1
            const userStats = getUserStats();
            if (!userStats) return;

            if (userStats.math.currentLevel > 1) {
                userStats.math.currentLevel--;
                userStats.math.questionsInLevel = 0;
                userStats.math.correctStreak = 0;
                showMathResult("¡Oh no! Has bajado al Nivel " + userStats.math.currentLevel, "level-down", 2000);
                playSound(levelDownSound, null, '0.3s');
            } else {
                showMathResult("¡Cuidado! Estás en el primer nivel.", "incorrect", 2000); // Should not happen if game over logic is correct
            }
            updateMathGameDisplay();
        }


        function updateMathTimer() {
            const userStats = getUserStats();
            if (!userStats) { // Should not happen if game is active
                clearTimeout(mathTimerId);
                return;
            }

            mathTimeLeft--;
            mathTimeLeftDisplay.textContent = mathTimeLeft;

            if (mathTimeLeft <= 5 && mathTimeLeft > 0) {
                mathTimerWrapper.classList.add('text-red-500');
                if (synthsInitialized && timerTickSound && mathTimeLeft % 2 === 0) playSound(timerTickSound, null, '32n'); // Tick sound
            } else {
                mathTimerWrapper.classList.remove('text-red-500');
            }

            if (mathTimeLeft <= 0) {
                clearTimeout(mathTimerId);
                showMathResult("¡Se acabó el tiempo! ", "incorrect");
                userStats.math.playerLives--;
                userStats.math.correctStreak = 0; // Reset streak
                playSound(incorrectSound, 'A2', '0.3s');
                playSound(lifeLostSound, 'G2', '0.1s', '+0.1');
                updateMathGameDisplay();
                if (userStats.math.playerLives <= 0) {
                    setTimeout(gameOverMath, 2000);
                } else {
                    setTimeout(nextMathProblem, 2000);
                }
                saveAllUsersData();
            }
        }

        function updateMathGameDisplay() {
            const userStats = getUserStats();
            if (!userStats) return;

            mathPlayerLivesDisplay.textContent = userStats.math.playerLives;
            mathCurrentLevelDisplay.textContent = userStats.math.currentLevel;
            mathCorrectStreakDisplay.textContent = userStats.math.correctStreak;
            mathCorrectPerLevelDisplay.textContent = MATH_CORRECT_PER_LEVEL;
            mathBestStreakDisplay.textContent = userStats.math.bestStreak;
            mathTimeLeftDisplay.textContent = mathTimeLeft; // Ensure this is also updated here

            const progress = userStats.math.playerLives > 0 ? (userStats.math.questionsInLevel / MATH_CORRECT_PER_LEVEL) * 100 : 0;
            mathProgressBarFill.style.width = `${progress}%`;
            mathProgressBarFill.textContent = `${Math.round(progress)}%`;
        }

        function showMathResult(message, type, duration = 1500) {
            mathGameResultDisplay.textContent = message;
            mathGameResultDisplay.className = 'result ' + type; // Apply base and specific class
            // Trigger reflow for animation restart if needed (e.g., for shake)
            mathGameResultDisplay.style.animation = 'none';
            void mathGameResultDisplay.offsetHeight; // Reflow
            mathGameResultDisplay.style.animation = null;

            if (type === "incorrect" || type === "level-down") {
                mathGameResultDisplay.classList.add('shake'); // Add shake animation class
            }
            // Note: The 'duration' parameter is not directly used here to hide the message.
            // Hiding/clearing is handled by nextMathProblem or gameOverMath.
        }

        function getCongratulationsMessage() {
            const userStats = getUserStats();
            if (!userStats) return "¡Felicidades!";
            const messageTemplate = congratulations[Math.floor(Math.random() * congratulations.length)];
            return messageTemplate.replace("{name}", currentLoggedInPlayer).replace("{level}", userStats.math.currentLevel);
        }

        function gameOverMath() {
            const userStats = getUserStats();
            if (!userStats) return;
            clearTimeout(mathTimerId);
            showMathResult(`¡Juego Terminado! Mejor racha: ${userStats.math.bestStreak}`, "incorrect", 3000);
            playSound(levelDownSound, null, '0.5s'); // Game over sound

            if (userStats.math.currentLevel > 1) levelDownMath(); // Level down if not on level 1

            // Trigger loot box based on performance (e.g., streak >= 3)
            if (userStats.math.bestStreak >= 3 && Math.random() < MATH_GAME_LOOT_BOX_PROBABILITY) {
                setTimeout(triggerLootBox, 1500); // Delay loot box appearance
            }

            userStats.math.correctStreak = 0; // Reset streak for next game
            userStats.math.questionsInLevel = 0; // Reset progress
            saveAllUsersData(); // Save final stats
            setTimeout(() => {
                showScreen('selection');
            }, 3000); // Delay before returning to selection
        }


        // --- Mind Twist Game V2 Logic ---
        function startMindTwistGameV2() {
            const userStats = getUserStats();
            if (!userStats) return;
            playSound(gameStartSound, 'D4', '0.5s');

            mindtwistV2DisplayPlayerName.textContent = currentLoggedInPlayer;
            mtV2_paused = false;
            mtV2PauseBtn.textContent = "⏸️ Pausar";

            // Start from highest reached level or level 0 if never played
            userStats.mindtwistV2.currentLevel = userStats.mindtwistV2.highestLevelReached || 0;
            userStats.mindtwistV2.totalAttempts++;

            loadMindTwistV2Level(userStats.mindtwistV2.currentLevel);
            clearTimeout(mtV2_timerId);
            mtV2_timeLeft = MT_V2_BASE_TIME_PER_LEVEL;
            updateMindTwistV2TimerDisplay();
            mtV2_timerId = setInterval(updateMindTwistV2TimerTick, 1000);
            checkAndAwardMedal("mindtwist_v2_first_try");
            saveAllUsersData();
        }

        function loadMindTwistV2Level(levelIndex) {
            const userStats = getUserStats();
            if (!userStats) return;

            const level = mindTwistV2Levels[levelIndex];
            if (!level) { // Completed all levels
                clearTimeout(mtV2_timerId);
                mtV2RiddleText.textContent = "¡Felicidades! Has completado todos los acertijos. ";
                mtV2OptionsContainer.innerHTML = "";
                mtV2NextBtn.style.display = 'none';
                mtV2HintBtn.style.display = 'none';
                mtV2PauseBtn.style.display = 'none';
                mtV2Feedback.textContent = `Total Resueltos: ${userStats.mindtwistV2.solvedCount}`;
                mtV2Feedback.className = "feedback-text correct";
                playSound(levelUpSound, ['C5', 'E5', 'G5', 'C6'], '0.7s');
                return;
            }

            mtV2LevelNumber.textContent = levelIndex + 1;
            mtV2RiddleText.textContent = level.riddle;
            mtV2Feedback.textContent = ""; // Clear previous feedback
            mtV2Feedback.className = "feedback-text";
            mtV2NextBtn.style.display = "none"; // Hide next button until correct
            mtV2HintBtn.style.display = "inline-block";
            mtV2PauseBtn.style.display = "inline-block";
            mtV2PauseBtn.textContent = "⏸️ Pausar";
            mtV2_paused = false;

            mtV2OptionsContainer.innerHTML = ""; // Clear old options
            level.options.forEach((option, i) => {
                const btn = document.createElement("button");
                btn.textContent = option;
                btn.className = "option-button";
                btn.onclick = () => handleMindTwistV2Answer(i, level.answer);
                mtV2OptionsContainer.appendChild(btn);
            });
            enableMindTwistV2Options();
        }

        function handleMindTwistV2Answer(selectedIndex, correctAnswerIndex) {
            if (mtV2_paused) return;
            const userStats = getUserStats();
            if (!userStats) return;

            if (selectedIndex === correctAnswerIndex) {
                playSound(mindTwistV2CorrectSound, 'E5', '0.1s');
                mtV2Feedback.textContent = "¡Correcto! ";
                mtV2Feedback.className = "feedback-text correct";
                mtV2NextBtn.style.display = "inline-block";
                disableMindTwistV2Options();
                userStats.mindtwistV2.solvedCount++;
                if (userStats.mindtwistV2.currentLevel >= userStats.mindtwistV2.highestLevelReached) {
                    userStats.mindtwistV2.highestLevelReached = userStats.mindtwistV2.currentLevel + 1;
                }
                checkAndAwardMedal("mindtwist_v2_solved_1");
                mtV2_timeLeft += MT_V2_TIME_INCREMENT_CORRECT; // Add time for correct answer
                updateMindTwistV2TimerDisplay();
                if (Math.random() < MINDTWIST_V2_LOOT_BOX_PROBABILITY) {
                    setTimeout(triggerLootBox, 500);
                }
            } else {
                playSound(mindTwistV2IncorrectSound, 'D3', '0.2s');
                mtV2Feedback.textContent = "Intenta de nuevo. ";
                mtV2Feedback.className = "feedback-text incorrect";
                mtV2_timeLeft = Math.max(0, mtV2_timeLeft - 5); // Penalty
                updateMindTwistV2TimerDisplay();
                if (mtV2_timeLeft <= 0) gameOverMindTwistV2();
            }
            saveAllUsersData();
        }

        function disableMindTwistV2Options() {
            Array.from(mtV2OptionsContainer.children).forEach(button => button.disabled = true);
        }
        function enableMindTwistV2Options() {
            Array.from(mtV2OptionsContainer.children).forEach(button => button.disabled = false);
        }

        mtV2HintBtn.onclick = () => {
            if (mtV2_paused) return;
            const userStats = getUserStats();
            if (!userStats) return;
            const level = mindTwistV2Levels[userStats.mindtwistV2.currentLevel];
            if (level && level.hint) {
                mtV2Feedback.textContent = `Pista: ${level.hint}`;
                mtV2Feedback.className = "feedback-text hint";
                userStats.mindtwistV2.hintsUsed = (userStats.mindtwistV2.hintsUsed || 0) + 1;
                saveAllUsersData();
            }
        };

        mtV2PauseBtn.onclick = () => {
            mtV2_paused = !mtV2_paused;
            mtV2PauseBtn.textContent = mtV2_paused ? "▶️ Reanudar" : "⏸️ Pausar";
            if (mtV2_paused) {
                clearTimeout(mtV2_timerId);
                mtV2Feedback.textContent = "Juego en pausa.";
                mtV2Feedback.className = "feedback-text paused";
                disableMindTwistV2Options(); // Disable options when paused
            } else {
                mtV2Feedback.textContent = ""; // Clear paused message
                mtV2Feedback.className = "feedback-text";
                if (mtV2NextBtn.style.display === 'none') { // Only enable if not already on a "next" screen
                    enableMindTwistV2Options();
                }
                if (mtV2_timeLeft > 0 && activeGame === 'mindtwist_v2') { // Resume timer if time left
                    mtV2_timerId = setInterval(updateMindTwistV2TimerTick, 1000);
                }
            }
        };

        mtV2NextBtn.onclick = () => {
            const userStats = getUserStats();
            if (!userStats) return;
            if (userStats.mindtwistV2.currentLevel < mindTwistV2Levels.length - 1) {
                userStats.mindtwistV2.currentLevel++;
                loadMindTwistV2Level(userStats.mindtwistV2.currentLevel);
                mtV2_timeLeft += 5; // Small time bonus for advancing
                updateMindTwistV2TimerDisplay();
            } else {
                // This case should be handled by loadMindTwistV2Level if all levels are done
                loadMindTwistV2Level(userStats.mindtwistV2.currentLevel + 1); // Will show completion message
            }
            saveAllUsersData();
        };

        function updateMindTwistV2TimerDisplay() {
            mindtwistV2TimeLeftDisplay.textContent = mtV2_timeLeft;
            if (mtV2_timeLeft <= 5 && mtV2_timeLeft > 0) {
                mindtwistV2TimerWrapper.classList.add('text-red-500');
            } else {
                mindtwistV2TimerWrapper.classList.remove('text-red-500');
            }
        }

        function updateMindTwistV2TimerTick() {
            if (mtV2_paused) return;
            const userStats = getUserStats();
            if (!userStats) { // Should not happen
                clearTimeout(mtV2_timerId);
                return;
            }
            mtV2_timeLeft--;
            updateMindTwistV2TimerDisplay();

            if (mtV2_timeLeft <= 5 && mtV2_timeLeft > 0) {
                if (synthsInitialized && timerTickSound && mtV2_timeLeft % 2 != 0) playSound(timerTickSound, null, '32n');
            }

            if (mtV2_timeLeft <= 0) {
                gameOverMindTwistV2();
            }
        }

        function gameOverMindTwistV2() {
            clearTimeout(mtV2_timerId);
            const userStats = getUserStats();
            if (!userStats) return;

            mtV2Feedback.textContent = "¡Se acabó el tiempo! ";
            mtV2Feedback.className = "feedback-text incorrect";
            mtV2NextBtn.style.display = 'none';
            disableMindTwistV2Options();
            playSound(incorrectSound, 'A2', '0.3s');

            if (userStats.mindtwistV2.solvedCount > 1 && Math.random() < MINDTWIST_V2_LOOT_BOX_PROBABILITY) {
                setTimeout(triggerLootBox, 500);
            }
            saveAllUsersData(); // Save before leaving
            setTimeout(() => showScreen('selection'), 3000);
        }


        // --- Simon Game Logic ---
        function startSimonGame() {
            const userStats = getUserStats();
            if (!userStats) return;
            playSound(gameStartSound, 'E4', '0.5s');

            simonGameActive = true;
            simonSequence = [];
            simonPlayerSequence = [];
            simonCurrentScore = 0;
            simonFeedbackDisplay.textContent = "Observa la secuencia...";
            simonScoreDisplay.textContent = simonCurrentScore;
            simonStartButton.disabled = true; // Disable start button during game

            userStats.simon.totalGamesPlayed++;
            checkAndAwardMedal("first_game");
            checkAndAwardMedal("simon_first_game");
            saveAllUsersData();

            setTimeout(simonNextComputerTurn, SIMON_ROUND_DELAY);
        }

        function simonNextComputerTurn() {
            if (!simonGameActive) return;
            simonTurn = 'computer';
            simonPlayerSequence = []; // Clear player's sequence for this turn
            simonFeedbackDisplay.textContent = "Observa...";
            disableSimonPads();

            const nextColor = SIMON_COLORS[Math.floor(Math.random() * SIMON_COLORS.length)];
            simonSequence.push(nextColor);
            playSimonSequence();
        }

        async function playSimonSequence() {
            await delay(SIMON_INTER_FLASH_DELAY / 2); // Brief pause before sequence starts
            for (const color of simonSequence) {
                if (!simonGameActive) return; // Stop if game ended prematurely
                await flashSimonPad(color, SIMON_FLASH_DURATION);
                await delay(SIMON_INTER_FLASH_DELAY); // Pause between flashes
            }
            if (simonGameActive) startPlayerTurnSimon();
        }

        async function flashSimonPad(color, duration) {
            const padElement = simonPadElements[color];
            if (!padElement) return;
            padElement.classList.add('active');
            playSound(simonPadSounds[color], getNoteForSimonColor(color), `${duration / 1000}s`);
            await delay(duration);
            padElement.classList.remove('active');
        }

        function getNoteForSimonColor(color) {
            switch (color) {
                case 'red': return 'C4';
                case 'green': return 'E4';
                case 'blue': return 'G4';
                case 'yellow': return 'B4'; // Changed from C5 for more distinction
                default: return 'C4';
            }
        }

        function startPlayerTurnSimon() {
            simonTurn = 'player';
            simonFeedbackDisplay.textContent = "¡Tu turno!";
            enableSimonPads();
        }

        function handleSimonPadClick(event) {
            if (!simonGameActive || simonTurn !== 'player') return;

            const clickedColor = event.target.dataset.color;
            if (!clickedColor) return;

            flashSimonPad(clickedColor, 150); // Shorter flash for player input
            simonPlayerSequence.push(clickedColor);

            const currentStep = simonPlayerSequence.length - 1;
            // Check if the clicked pad matches the sequence at the current step
            if (simonPlayerSequence[currentStep] !== simonSequence[currentStep]) {
                gameOverSimon("¡Incorrecto! ");
                return;
            }

            // If player completed the current sequence
            if (simonPlayerSequence.length === simonSequence.length) {
                simonCurrentScore += simonSequence.length; // Or some other scoring logic
                simonScoreDisplay.textContent = simonCurrentScore;
                playSound(correctSound, 'C5', '0.1s');
                checkAndAwardMedal("simon_score_50");
                if (simonSequence.length >= 5) checkAndAwardMedal("simon_sequence_5");

                disableSimonPads();
                simonFeedbackDisplay.textContent = "¡Bien hecho! ";
                setTimeout(simonNextComputerTurn, SIMON_ROUND_DELAY);
            }
        }

        function gameOverSimon(message) {
            playSound(incorrectSound, 'C3', '0.3s');
            simonFeedbackDisplay.textContent = `${message} Puntuación final: ${simonCurrentScore}.`;
            simonGameActive = false;
            simonStartButton.disabled = false; // Re-enable start button
            disableSimonPads();

            const userStats = getUserStats();
            if (!userStats) return;

            if (simonCurrentScore > userStats.simon.highestScore) {
                userStats.simon.highestScore = simonCurrentScore;
                showNotification(`¡Nuevo récord en Simón: ${simonCurrentScore} puntos!`, 'streak');
                addToLeaderboard(currentLoggedInPlayer, simonCurrentScore, 'simon');
            }
            // Longest sequence remembered correctly in this game
            const rememberedSequenceLength = simonSequence.length > 0 ? simonSequence.length -1 : 0;
            if (rememberedSequenceLength > userStats.simon.longestSequence) {
                userStats.simon.longestSequence = rememberedSequenceLength;
            }

            if (simonCurrentScore > 20 && Math.random() < SIMON_LOOT_BOX_PROBABILITY) {
                setTimeout(triggerLootBox, 500);
            }

            saveAllUsersData();
            updateSelectionScreenStats(); // Update summary on selection screen
        }

        function enableSimonPads() {
            Object.values(simonPadElements).forEach(pad => pad.disabled = false);
        }
        function disableSimonPads() {
            Object.values(simonPadElements).forEach(pad => pad.disabled = true);
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }


        // --- Number Memory Game Logic ---
        const NM_MAX_LEVEL_NM = 20; // Max level for this specific game

        class MemoryNumbersGame {
            constructor(userStatsRef, saveCallback, checkMedalCallback, addToLeaderboardCallback) {
                this.userStats = userStatsRef;
                this.saveDataCallback = saveCallback;
                this.checkMedalCallback = checkMedalCallback;
                this.addToLeaderboardCallback = addToLeaderboardCallback;

                this.sequence = [];
                this.playerSequence = [];
                this.level = 1;
                this.score = 0;
                this.gameActive = false;
                this.showingSequence = false; // To prevent clicks while sequence is shown
                this.gridSize = 4; // Default, will be set by difficulty
                this.difficulty = this.userStats.numberMemory.currentDifficulty || 'medium';
                this.maxLevel = NM_MAX_LEVEL_NM; // Use the game-specific max level

                this.bindEvents();
                this.initializeGame(); // Initial setup of the board based on difficulty
            }

            initializeGame() {
                const cardCountConfig = { easy: 9, medium: 16, hard: 20, expert: 25 };
                const currentCards = cardCountConfig[this.difficulty] || 16;
                this.gridSize = Math.ceil(Math.sqrt(currentCards)); // e.g. 9->3x3, 16->4x4, 20->5x4 (approx 5x5), 25->5x5

                nmGameBoardElem.style.gridTemplateColumns = `repeat(${this.gridSize}, 1fr)`;
                // Dynamically adjust max-width for better appearance based on grid size
                const approxCardAndGap = (nmGameBoardElem.clientWidth / this.gridSize) -10; // Estimate card size
                nmGameBoardElem.style.maxWidth = `${this.gridSize * (approxCardAndGap + 10)}px`; // Add back gap

                this.createGameBoard();
                this.updateDisplay();
            }

            createGameBoard() {
                nmGameBoardElem.innerHTML = '';
                const totalNumbers = this.gridSize * this.gridSize;
                for (let i = 1; i <= totalNumbers; i++) {
                    const card = document.createElement('button');
                    card.className = 'nm-number-card hidden'; // Start hidden
                    card.textContent = i;
                    card.dataset.number = i;
                    card.addEventListener('click', () => this.handleCardClick(i));
                    nmGameBoardElem.appendChild(card);
                }
                this.disableCardClicks(); // Cards disabled initially
            }

            bindEvents() {
                nmStartBtn.onclick = () => this.startGame();
                nmShowSequenceBtn.onclick = () => this.showSequenceVisual(true); // Allow forced show
                nmResetBtn.onclick = () => this.resetGame();
                nmDifficultySelect.onchange = () => this.changeDifficulty();
            }

            changeDifficulty() {
                this.difficulty = nmDifficultySelect.value;
                this.userStats.numberMemory.currentDifficulty = this.difficulty;
                this.resetGame(); // Reset game with new difficulty
                this.saveDataCallback();
            }

            getSequenceLength() {
                const baseLengths = { easy: 3, medium: 4, hard: 5, expert: 6 };
                let length = baseLengths[this.difficulty] || 4;
                length += Math.floor((this.level - 1) / 2); // Increase length every 2 levels
                return Math.min(length, (this.gridSize * this.gridSize) - 1); // Max length is one less than total cards
            }

            startGame() {
                playSound(gameStartSound, 'F4', '0.4s');
                this.userStats.numberMemory.gamesPlayed++;
                this.checkMedalCallback("nm_first_game");

                this.level = 1;
                this.score = 0;
                this.updateDisplay();
                this.gameActive = true;
                nmStartBtn.style.display = 'none';
                nmShowSequenceBtn.style.display = 'inline-block';
                nmDifficultySelect.disabled = true;
                this.hideAllCards(); // Ensure cards are hidden before starting
                this.nextLevel(); // Start the first level
            }

            nextLevel() {
                if (!this.gameActive) return;
                if (this.level > this.maxLevel) {
                    this.gameComplete();
                    return;
                }
                this.generateSequence();
                this.showSequenceVisual();
                this.showMessage(`Nivel ${this.level} - ¡Memoriza la secuencia!`, 'info');
            }

            gameComplete() {
                this.gameActive = false;
                this.showMessage(`¡Felicidades! Has completado todos los ${this.maxLevel} niveles. Puntuación Final: ${this.score} `, 'success');
                nmStartBtn.style.display = 'inline-block';
                nmShowSequenceBtn.style.display = 'none';
                nmStartBtn.textContent = 'Jugar de Nuevo';
                nmDifficultySelect.disabled = false;
                this.disableCardClicks();
                this.saveDataCallback();
                updateSelectionScreenStats(); // Update overall stats
                if (this.score > 0 && Math.random() < NUMBER_MEMORY_LOOT_BOX_PROBABILITY) {
                    setTimeout(triggerLootBox, 500);
                }
            }

            generateSequence() {
                const sequenceLength = this.getSequenceLength();
                this.sequence = [];
                const allNumbers = Array.from({ length: this.gridSize * this.gridSize }, (_, i) => i + 1);

                // Shuffle allNumbers to pick a random sequence
                for (let i = allNumbers.length - 1; i > 0; i--) { // Fisher-Yates shuffle
                    const j = Math.floor(Math.random() * (i + 1));
                    [allNumbers[i], allNumbers[j]] = [allNumbers[j], allNumbers[i]];
                }
                this.sequence = allNumbers.slice(0, sequenceLength);
                this.playerSequence = []; // Reset player sequence
            }

            async showSequenceVisual(forceShow = false) {
                if ((!this.gameActive && !forceShow) || this.showingSequence) return; // Don't show if game not active (unless forced) or already showing
                this.showingSequence = true;
                this.disableCardClicks();
                nmSequenceDisplayElem.textContent = `Secuencia: ${this.sequence.join(' → ')}`;
                this.hideAllCards(); // Make sure all cards are hidden before showing new sequence

                await delay(500); // Pause before showing

                for (let i = 0; i < this.sequence.length; i++) {
                    if ((!this.gameActive && !forceShow)) break; // Stop if game ended or not forced
                    this.highlightCard(this.sequence[i]);
                    playSound(nmSequenceHighlightSound, 'C5', '0.1s');
                    await delay(800); // How long each card is highlighted
                    this.unhighlightCard(this.sequence[i]);
                    if (i < this.sequence.length - 1) await delay(300); // Pause between cards
                }

                if (this.gameActive) { // If game is still active after showing sequence
                    await delay(500); // Pause after sequence
                    nmSequenceDisplayElem.textContent = ''; // Clear sequence display
                    this.showingSequence = false;
                    this.enableCardClicks();
                    this.showMessage('¡Ahora repite la secuencia seleccionando las tarjetas!', 'info');
                } else if (forceShow) { // If forced (e.g. "Show Sequence" button)
                    await delay(500);
                    nmSequenceDisplayElem.textContent = '';
                    this.showingSequence = false;
                    this.disableCardClicks(); // Keep cards disabled after manual show
                }
            }

            hideAllCards() {
                const cards = nmGameBoardElem.querySelectorAll('.nm-number-card');
                cards.forEach(card => {
                    card.classList.remove('flipped', 'pulse-effect');
                    card.classList.add('hidden');
                });
            }
            disableCardClicks() {
                Array.from(nmGameBoardElem.children).forEach(c => c.disabled = true);
            }
            enableCardClicks() {
                Array.from(nmGameBoardElem.children).forEach(c => c.disabled = false);
            }

            highlightCard(number) {
                const card = nmGameBoardElem.querySelector(`[data-number="${number}"]`);
                if (card) {
                    card.classList.remove('hidden');
                    card.classList.add('pulse-effect'); // Visual feedback for highlight
                }
            }
            unhighlightCard(number) {
                const card = nmGameBoardElem.querySelector(`[data-number="${number}"]`);
                if (card) {
                    card.classList.remove('pulse-effect');
                    card.classList.add('hidden'); // Hide after highlight
                }
            }

            handleCardClick(number) {
                if (!this.gameActive || this.showingSequence) return;
                playSound(nmCardClickSound, 'A4', '0.05s');

                const card = nmGameBoardElem.querySelector(`[data-number="${number}"]`);
                if (card) {
                    card.classList.remove('hidden');
                    card.classList.add('flipped'); // Show the card number
                    card.disabled = true; // Prevent re-clicking
                }

                this.playerSequence.push(number);

                // Check if the clicked number is correct for the current step in the sequence
                if (this.playerSequence[this.playerSequence.length - 1] !== this.sequence[this.playerSequence.length - 1]) {
                    playSound(nmErrorSound, 'C3', '0.2s');
                    this.gameOver();
                    return;
                }

                // If player has completed the sequence
                if (this.playerSequence.length === this.sequence.length) {
                    this.levelComplete();
                }
            }

            levelComplete() {
                playSound(correctSound, 'G5', '0.2s');
                this.score += this.level * (this.sequence.length * 2); // Example scoring
                this.level++;
                if (this.level > this.userStats.numberMemory.highestLevelReached) {
                    this.userStats.numberMemory.highestLevelReached = this.level;
                }
                if (this.score > this.userStats.numberMemory.highestScore) {
                    this.userStats.numberMemory.highestScore = this.score;
                    this.addToLeaderboardCallback(currentLoggedInPlayer, this.score, 'numberMemory');
                }
                this.checkMedalCallback("nm_score_100");
                this.updateDisplay();
                this.showMessage(`¡Nivel ${this.level - 1} completado! `, 'success');
                this.disableCardClicks(); // Disable cards while transitioning
                this.hideAllCards(); // Hide cards before next level's sequence
                setTimeout(() => this.nextLevel(), 2000); // Delay before next level
            }

            gameOver() {
                playSound(nmErrorSound || incorrectSound, 'D3', '0.3s'); // Fallback to generic incorrect sound
                this.gameActive = false;
                this.showMessage(`¡Juego terminado! Puntuación final: ${this.score} `, 'error');
                nmStartBtn.style.display = 'inline-block';
                nmShowSequenceBtn.style.display = 'none';
                nmStartBtn.textContent = 'Jugar de Nuevo';
                nmDifficultySelect.disabled = false;
                this.disableCardClicks();
                this.saveDataCallback();
                updateSelectionScreenStats();
                if (this.score > 50 && Math.random() < NUMBER_MEMORY_LOOT_BOX_PROBABILITY) {
                    setTimeout(triggerLootBox, 500);
                }
            }

            resetGame() {
                this.sequence = [];
                this.playerSequence = [];
                this.level = 1;
                this.score = 0;
                this.gameActive = false;
                this.showingSequence = false;
                this.difficulty = nmDifficultySelect.value; // Ensure difficulty is current
                this.userStats.numberMemory.currentDifficulty = this.difficulty;

                this.initializeGame(); // Re-create board for new difficulty if changed

                nmStartBtn.style.display = 'inline-block';
                nmShowSequenceBtn.style.display = 'none';
                nmStartBtn.textContent = 'Comenzar';
                nmDifficultySelect.disabled = false;
                nmSequenceDisplayElem.textContent = '';
                this.hideMessage();
                this.updateDisplay();
                this.saveDataCallback(); // Save difficulty preference
            }
            pauseGameForScreenChange() {
                // This method is called when switching screens, to stop any ongoing processes
                this.showingSequence = false; // Stop sequence if it's showing
                this.gameActive = false;
                this.disableCardClicks();
                this.hideMessage();
                this.hideAllCards();
                nmDifficultySelect.disabled = false; // Re-enable difficulty selector
            }


            updateDisplay() {
                nmLevelDisplayElem.textContent = this.level;
                nmScoreDisplayElem.textContent = this.score;
                nmBestScoreDisplayElem.textContent = this.userStats.numberMemory.highestScore || 0;
                nmDifficultySelect.value = this.difficulty; // Reflect current difficulty in dropdown
            }

            showMessage(text, type) {
                nmGameMessageElem.textContent = text;
                nmGameMessageElem.className = `nm-game-message nm-message-${type} show`;
            }
            hideMessage() {
                nmGameMessageElem.classList.remove('show');
            }
        }

        function startNumberMemoryGame() {
            playSound(gameStartSound, 'F4', '0.4s');
            const userStats = getUserStats();
            if (!userStats) return;

            // Ensure numberMemory stats exist
            if (!userStats.numberMemory) { // If loading old data that didn't have this game
                userStats.numberMemory = defaultPlayerStats().numberMemory;
            }

            if (!nmGameInstance) {
                nmGameInstance = new MemoryNumbersGame(userStats, saveAllUsersData, checkAndAwardMedal, addToLeaderboard);
            } else {
                nmGameInstance.userStats = userStats; // Update with current stats
                nmGameInstance.difficulty = userStats.numberMemory.currentDifficulty || 'medium'; // Ensure difficulty is up-to-date
            }
            nmGameInstance.resetGame(); // Always reset to ensure clean start
        }


        // --- Sliding Puzzle Game Logic ---
        const SM_CANVAS_WIDTH_SM = 400; // Renamed
        const SM_CANVAS_HEIGHT_SM = 400; // Renamed
        const SM_COLORS_SM = { // Renamed
            WALL: '#4A5568', PATH: '#E2E8F0', START: '#48BB78', END: '#E53E3E',
            GAP: '#CBD5E0', PLAYER: '#4299E1', HIGHLIGHT: '#ECC94B', TEXT: '#2D3748',
            PLAYER_OUTLINE: '#2B6CB0'
        };

        class LevelManagerSM { // Renamed
            constructor() {
                this.levels = [
                    // Nivel 0 (anteriormente 1)
                    ["WWWWW", "SPPPG", "WWWWW", "WWPEW", "WWWWW"],
                    // Nivel 1 (anteriormente 2)
                    ["WSWWW", "WPWWW", "WPGWW", "WPWWW", "WEWWW"],
                    // Nivel 2 (anteriormente 3)
                    ["WWWWWW", "SPPWPG", "WWPWPW", "WPPWPW", "WPPGWW", "WWEWWW"],
                    // Nivel 3 (anteriormente 4)
                    ["WWWWWW", "SPWPPW", "WPWPWW", "WPPPGP", "WWWWPE", "GPPWWW"],
                    // Nivel 4 (anteriormente 5)
                    ["WWWWWWW", "SPPPPPW", "WWWWPWW", "WPPPPWG", "WPWWWWW", "WPPPPPE", "WWWWWWW"],
                     // Nivel 5
                    ["WWWWWWW", "SPWPPPW", "WPWPWPW", "WPPWPPW", "WWWWPWW", "WPPPPPG", "WWWWWEW"],
                    // Nivel 6
                    ["WWWWWWWW", "SPPPWPPW", "WWWPWPPW", "WPPPPPPW", "WPWWWWWW", "WPPPPPPG", "WWWWWPWW", "WPPPPPEW"],
                    // Nivel 7
                    ["WWWWWWWW", "SPPWPPPW", "WWPWPPPW", "WPPWPPPW", "WPWPWWPW", "WPWPPGPW", "WPPWPPWW", "WPPEWWWW"],
                    // Nivel 8
                    ["WWWWWWWWW", "SPPWPWPPW", "WPWWPWWPW", "WPPWPPPPW", "WWWWWWPWW", "WPPPPPPPW", "WPWWWWWPW", "GPPPPPPPE", "WWWWWWWWW"],
                    // Nivel 9
                    ["WWWWWWWWW", "SPWPWPPPW", "WPWWPWPWW", "WPPPPPPPW", "WPWWWWPWW", "WPPPWPPWW", "WWWWPPPPE", "WPWWWWWPW", "GWWWWWWWW"],
                    // Nivel 10 (Más complejo)
                    ["WWWWWWWWWW", "SPWPWPPPWW", "PWPWWPWPPW", "WPPPPPPPPW", "WPWWWWWPWW", "PPPPPPGPPW", "PWPWPWWPWW", "PPPPPPPPPW", "PWWWWWWWPW", "WWWWWWWWWE"],
                    // Nivel 11
                    ["WWWWWWWWWW", "SPPWWPPWPP", "WPWPWWPWPW", "WPPWPPPWPW", "WPWWWWWPWW", "PPPPPWPPPE", "PWPWPWWPWW", "PPPPPPGPPW", "WPWWWPWWWW", "WWWWWWWWWW"],
                    // Nivel 12
                    ["WWWWWWWWWW", "SPWWWPWWPP", "PWWWPWPPPW", "WPWPWWWWPW", "WPWWWWWPPW", "WPPPPPPPGW", "WPWWWPWWPW", "PWWWPWWPPW", "WPWWWPWWWP", "WWWWWWWWWE"],
                    // Nivel 13
                    ["WWWWWWWWWW", "SPWPPWPPPE", "WPPWWPWPPW", "WPPPWPPPPW", "WPWWWWPWGW", "PPWPPWPPPW", "PWPPWWPWWW", "PPPPPPPPPW", "WWPWWWPWWW", "WWWWWWWWWW"],
                    // Nivel 14
                    ["WWWWWWWWWW", "SPWPWPWPWP", "WPPWPWPWPW", "WPWPWPWPWW", "WPPWPWPWPW", "WPWPWPWPGW", "WPPWPWPWPW", "WPWPWPWPWW", "WPPWPWPWEW", "WWWWWWWWWW"],
                    // Nivel 15 - Reto de 12x12
                    ["WWWWWWWWWWWW","SPWPWPPPWPEW","PWPWWPWPPWPW","WPPPPPPPPPPW","WPWWWWWPWPWW","PGPWPWPPWPPW","PWPWPWPWPWPW","PPPPPPPPPPPP","PWWWWWWWWPWP","PPPPPPPPPPPP","WWWWWWWWWWWW","WWWWWWWWWWWW"],
                    // Nivel 16
                    ["WWWWWWWWWWWW","SPWPWWPPWWPW","WPPPPWWPWWPW","WPWWWPWWPWPW","WPPWPWWPWWWW","WPWWWPWPPPWW","WPPWPWWPWWWP","WPPWPWWPPWPW","WPPWPWWPWWPE","WPPPPPPWPPPG","WWWWWWWWWWWW","WWWWWWWWWWWW"],
                    // Nivel 17
                    ["WWWWWWWWWWWW","SPWPWWPPWWPW","PWPWWPWPPWPW","WPPPPPPPPPPW","WPWWWWWPWPWW","PGPWPWPPWPPW","PWPWPWPWPWPW","PWPWPWPWPWPW","PWPWPWPWPWPW","PWPWPWPWPWPE","WWWWWWWWWWWW","WWWWWWWWWWWW"],
                    // Nivel 18
                    ["WWWWWWWWWWWW","SPWPPWPPWPPW","PWPWPWPWPWPW","SPWPPWPPWPPW","PWPWPWPWPWPW","SPWPPWPPWPPW","PWPWPWPWPWPW","SPWPPWPPWPPW","PWPWPWPWPWPW","SPWPPWPPWPEG","WWWWWWWWWWWW","WWWWWWWWWWWW"],
                    // Nivel 19 - Final Boss (Casi todo pasillos)
                    ["WWWWWWWWWWWW","SPPPPPPPPPPW","WPPPPPPPPPPW","WPPPPPPPPPPW","WPPPPPPPPPPW","WPPPPPPPPPPW","WPPPPPPPPPPW","WPPPPPPPPPPW","WPPPPPPPPPPW","WPPPPPPPPPEG","WWWWWWWWWWWW","WWWWWWWWWWWW"]
                ];
            }
            get_level(index) { return (index >= 0 && index < this.levels.length) ? this.levels[index] : null; }
            get_total_levels() { return this.levels.length; }
        }

        class PlayerSM { // Renamed
            constructor(pixelPos, radius) { this.x = pixelPos.x; this.y = pixelPos.y; this.radius = radius; }
            update_position_px(newPixelPos) { this.x = newPixelPos.x; this.y = newPixelPos.y; }
            draw(ctx) {
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = SM_COLORS_SM.PLAYER; ctx.fill();
                ctx.strokeStyle = SM_COLORS_SM.PLAYER_OUTLINE; ctx.lineWidth = 2; ctx.stroke();
            }
        }

        class MazeSM { // Renamed
            constructor(levelData, canvasWidth, canvasHeight) {
                this.grid = levelData.map(rowStr => rowStr.split(''));
                this.rows = this.grid.length; this.cols = this.grid[0].length;
                this.canvasWidth = canvasWidth; this.canvasHeight = canvasHeight;
                this.offsetX = 0; this.offsetY = 0; this.cellSize = 0;
                this.start_pos_grid = null; this.end_pos_grid = null; this.gap_pos_grid = null; this.player_pos_grid = null;
                this.find_special_cells(); this._calculateDrawingParameters();
                this.selected_slide_row = null; this.selected_slide_col = null;
            }

            find_special_cells() {
                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                        if (this.grid[r][c] === 'S') {
                            this.start_pos_grid = [r, c]; this.player_pos_grid = [r, c]; this.grid[r][c] = 'P'; // Convert S to P
                        } else if (this.grid[r][c] === 'E') { this.end_pos_grid = [r, c];
                        } else if (this.grid[r][c] === 'G') { this.gap_pos_grid = [r, c]; }
                    }
                }
            }

            _calculateDrawingParameters() {
                const marginFactor = 0.95; // Use 95% of canvas for the maze
                const max_width_for_maze = this.canvasWidth * marginFactor;
                const max_height_for_maze = this.canvasHeight * marginFactor;

                const cell_width_based_on_cols = max_width_for_maze / this.cols;
                const cell_height_based_on_rows = max_height_for_maze / this.rows;
                this.cellSize = Math.min(cell_width_based_on_cols, cell_height_based_on_rows);

                const total_maze_width = this.cols * this.cellSize;
                const total_maze_height = this.rows * this.cellSize;
                this.offsetX = (this.canvasWidth - total_maze_width) / 2;
                this.offsetY = (this.canvasHeight - total_maze_height) / 2;
            }

            get_cell_pixel_coords(row, col) { return { x: this.offsetX + col * this.cellSize, y: this.offsetY + row * this.cellSize }; }
            get_cell_center_coords(row, col) { return { x: this.offsetX + col * this.cellSize + this.cellSize / 2, y: this.offsetY + row * this.cellSize + this.cellSize / 2 }; }
            get_grid_coords_from_pixels(x_px, y_px) {
                const col = Math.floor((x_px - this.offsetX) / this.cellSize);
                const row = Math.floor((y_px - this.offsetY) / this.cellSize);
                return (row >= 0 && row < this.rows && col >= 0 && col < this.cols) ? [row, col] : null;
            }

            draw(ctx) {
                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                        const { x, y } = this.get_cell_pixel_coords(r, c);
                        let color;
                        switch (this.grid[r][c]) {
                            case 'W': color = SM_COLORS_SM.WALL; break; case 'P': color = SM_COLORS_SM.PATH; break;
                            case 'E': color = SM_COLORS_SM.END; break; case 'G': color = SM_COLORS_SM.GAP; break;
                            default: color = SM_COLORS_SM.PATH; break;
                        }
                        ctx.fillStyle = color; ctx.fillRect(x, y, this.cellSize, this.cellSize);
                        ctx.strokeStyle = SM_COLORS_SM.TEXT; ctx.lineWidth = 1; ctx.strokeRect(x, y, this.cellSize, this.cellSize);
                    }
                }
                // Draw E and G text
                ctx.font = `${this.cellSize * 0.6}px Fredoka One`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                if (this.end_pos_grid && !(this.player_pos_grid[0] === this.end_pos_grid[0] && this.player_pos_grid[1] === this.end_pos_grid[1])) { // Don't draw E if player is on it
                    const { x, y } = this.get_cell_pixel_coords(this.end_pos_grid[0], this.end_pos_grid[1]);
                    ctx.fillStyle = SM_COLORS_SM.TEXT; ctx.fillText('E', x + this.cellSize / 2, y + this.cellSize / 2);
                }
                if (this.gap_pos_grid) {
                    const { x, y } = this.get_cell_pixel_coords(this.gap_pos_grid[0], this.gap_pos_grid[1]);
                    ctx.fillStyle = SM_COLORS_SM.TEXT; ctx.fillText('G', x + this.cellSize / 2, y + this.cellSize / 2);
                }

                // Highlight selected row/column
                if (this.selected_slide_row !== null) {
                    ctx.strokeStyle = SM_COLORS_SM.HIGHLIGHT; ctx.lineWidth = 3;
                    const { x, y } = this.get_cell_pixel_coords(this.selected_slide_row, 0);
                    ctx.strokeRect(x, y, this.cols * this.cellSize, this.cellSize);
                } else if (this.selected_slide_col !== null) {
                    ctx.strokeStyle = SM_COLORS_SM.HIGHLIGHT; ctx.lineWidth = 3;
                    const { x, y } = this.get_cell_pixel_coords(0, this.selected_slide_col);
                    ctx.strokeRect(x, y, this.cellSize, this.rows * this.cellSize);
                }
            }
            can_select_for_slide(row, col) {
                // Can select if it's in the same row or col as the gap, but not the gap itself, and not the player's current cell
                return ((row === this.gap_pos_grid[0] && col !== this.gap_pos_grid[1]) || (col === this.gap_pos_grid[1] && row !== this.gap_pos_grid[0])) &&
                       !(row === this.player_pos_grid[0] && col === this.player_pos_grid[1]);
            }

            slide_row(row_index, direction) {
                if (row_index !== this.gap_pos_grid[0]) return; playSound(smSlideSound, null, '0.1s');
                let row_data = this.grid[row_index]; let new_gap_col = this.gap_pos_grid[1]; let new_player_col = this.player_pos_grid[1];
                if (direction === 'left') {
                    row_data.push(row_data.shift()); new_gap_col = (new_gap_col === 0) ? this.cols - 1 : new_gap_col - 1;
                    if (this.player_pos_grid[0] === row_index) new_player_col = (new_player_col === 0) ? this.cols - 1 : new_player_col - 1;
                } else if (direction === 'right') {
                    row_data.unshift(row_data.pop()); new_gap_col = (new_gap_col === this.cols - 1) ? 0 : new_gap_col + 1;
                    if (this.player_pos_grid[0] === row_index) new_player_col = (new_player_col === this.cols - 1) ? 0 : new_player_col + 1;
                } else return;
                this.grid[row_index] = row_data; this.gap_pos_grid = [row_index, new_gap_col];
                if (this.player_pos_grid[0] === row_index) this.player_pos_grid = [row_index, new_player_col];
            }

            slide_column(col_index, direction) {
                if (col_index !== this.gap_pos_grid[1]) return; playSound(smSlideSound, null, '0.1s');
                let col_data = []; for (let r = 0; r < this.rows; r++) col_data.push(this.grid[r][col_index]);
                let new_gap_row = this.gap_pos_grid[0]; let new_player_row = this.player_pos_grid[0];
                if (direction === 'up') {
                    col_data.push(col_data.shift()); new_gap_row = (new_gap_row === 0) ? this.rows - 1 : new_gap_row - 1;
                    if (this.player_pos_grid[1] === col_index) new_player_row = (new_player_row === 0) ? this.rows - 1 : new_player_row - 1;
                } else if (direction === 'down') {
                    col_data.unshift(col_data.pop()); new_gap_row = (new_gap_row === this.rows - 1) ? 0 : new_gap_row + 1;
                    if (this.player_pos_grid[1] === col_index) new_player_row = (new_player_row === this.rows - 1) ? 0 : new_player_row + 1;
                } else return;
                for (let r = 0; r < this.rows; r++) this.grid[r][col_index] = col_data[r];
                this.gap_pos_grid = [new_gap_row, col_index];
                if (this.player_pos_grid[1] === col_index) this.player_pos_grid = [new_player_row, col_index];
            }
            check_win() { return this.player_pos_grid[0] === this.end_pos_grid[0] && this.player_pos_grid[1] === this.end_pos_grid[1]; }
        }

        class SlidingMazeGame {
            constructor(userStatsRef, saveCallback, checkMedalCallback, addToLeaderboardCallback) {
                this.userStats = userStatsRef; this.saveDataCallback = saveCallback;
                this.checkMedalCallback = checkMedalCallback; this.addToLeaderboardCallback = addToLeaderboardCallback;
                this.levelManager = new LevelManagerSM(); this.currentLevelIndex = this.userStats.slidingPuzzle.currentLevel || 0;
                this.maze = null; this.player = null; this.gameActive = false; this.levelComplete = false; this.gameOver = false;
                this.animationFrameId = null; this.canvas = smCanvas; this.ctx = smCtx;
                this.boundHandleKeyDown = this.handleKeyDown.bind(this); this.boundHandleMouseDown = this.handleMouseDown.bind(this);
                this.boundLoop = this.loop.bind(this);

                smStartBtn.onclick = () => this.startGame(); smResetBtn.onclick = () => this.resetCurrentLevel(); smNextBtn.onclick = () => this.nextLevel();
                this.updateDisplay();
            }

            startGame() {
                if (this.gameActive && !this.gameOver) return; playSound(gameStartSound, 'G4', '0.4s');
                this.userStats.slidingPuzzle.totalGamesPlayed++; this.currentLevelIndex = 0; // Start from level 0 (first level)
                this.loadCurrentLevel(); this.gameActive = true; this.gameOver = false; this.levelComplete = false;
                smStartBtn.style.display = 'none'; smResetBtn.style.display = 'inline-block'; smNextBtn.style.display = 'none';
                this.showMessage("¡Mueve las piezas para alcanzar la 'E'!", 'info'); this.startLoop();
                this.checkMedalCallback("first_game"); this.saveDataCallback();
            }

            loadCurrentLevel() {
                this.stopLoop(); this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const levelData = this.levelManager.get_level(this.currentLevelIndex);
                if (levelData) {
                    this.maze = new MazeSM(levelData, this.canvas.width, this.canvas.height);
                    const playerStartPixelPos = this.maze.get_cell_center_coords(this.maze.player_pos_grid[0], this.maze.player_pos_grid[1]);
                    this.player = new PlayerSM(playerStartPixelPos, this.maze.cellSize / 2 * 0.7);
                    this.levelComplete = false; this.gameOver = false; this.maze.selected_slide_row = null; this.maze.selected_slide_col = null;
                    this.updateDisplay(); this.draw();
                } else { // All levels completed
                    this.gameOver = true; this.gameActive = false;
                    this.showMessage("¡Felicidades, has completado todos los niveles! ", 'success');
                    playSound(smWinSound, ['E5', 'G5', 'C6'], '0.7s');
                    smNextBtn.style.display = 'none'; smStartBtn.style.display = 'inline-block'; smStartBtn.textContent = 'Jugar de Nuevo';
                    if (this.userStats.slidingPuzzle.highestLevelReached >= this.levelManager.get_total_levels() && Math.random() < SLIDING_PUZZLE_LOOT_BOX_PROBABILITY) {
                        setTimeout(triggerLootBox, 1000);
                    }
                    this.saveDataCallback();
                }
            }

            resetCurrentLevel() {
                playSound(smClickSound, null, '16n'); this.loadCurrentLevel();
                this.gameActive = true; this.levelComplete = false; this.gameOver = false;
                smNextBtn.style.display = 'none'; smStartBtn.style.display = 'none'; smResetBtn.style.display = 'inline-block';
                this.showMessage("Nivel reiniciado. ¡Vamos!", 'info'); this.startLoop(); this.saveDataCallback();
            }

            nextLevel() {
                playSound(smClickSound, null, '16n'); this.currentLevelIndex++;
                if (this.currentLevelIndex < this.levelManager.get_total_levels()) {
                    this.loadCurrentLevel(); this.gameActive = true; this.levelComplete = false;
                    smNextBtn.style.display = 'none'; this.showMessage(`¡Nivel ${this.currentLevelIndex + 1}!`, 'info');
                    this.startLoop();
                } else { this.loadCurrentLevel(); } // Will show completion message
                this.userStats.slidingPuzzle.currentLevel = this.currentLevelIndex; // Save progress
                this.saveDataCallback();
            }

            startLoop() {
                if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId); // Clear previous loop
                this.animationFrameId = requestAnimationFrame(this.boundLoop);
                document.addEventListener('keydown', this.boundHandleKeyDown);
                this.canvas.addEventListener('mousedown', this.boundHandleMouseDown);
            }
            stopLoop() {
                cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null;
                document.removeEventListener('keydown', this.boundHandleKeyDown);
                this.canvas.removeEventListener('mousedown', this.boundHandleMouseDown);
            }

            handleMouseDown(event) {
                if (!this.gameActive || this.levelComplete || this.gameOver) return;
                const rect = this.canvas.getBoundingClientRect();
                const x_px = event.clientX - rect.left; const y_px = event.clientY - rect.top;
                const gridCoords = this.maze.get_grid_coords_from_pixels(x_px, y_px);
                if (gridCoords) {
                    const [row, col] = gridCoords;
                    if (this.maze.can_select_for_slide(row, col)) {
                        playSound(smClickSound, null, '32n');
                        if (row === this.maze.gap_pos_grid[0]) { this.maze.selected_slide_row = row; this.maze.selected_slide_col = null; this.showMessage("¡Fila seleccionada! Usa ← → para deslizar.", 'info'); }
                        else if (col === this.maze.gap_pos_grid[1]) { this.maze.selected_slide_col = col; this.maze.selected_slide_row = null; this.showMessage("¡Columna seleccionada! Usa ↑ ↓ para deslizar.", 'info'); }
                    } else { this.maze.selected_slide_row = null; this.maze.selected_slide_col = null; this.showMessage("No puedes seleccionar esa celda.", 'error'); }
                    this.draw();
                }
            }

            handleKeyDown(event) {
                if (this.gameOver || this.levelComplete) { if (event.key.toLowerCase() === 'r') this.startGame(); return; }
                let moved = false;
                if (this.maze.selected_slide_row !== null) {
                    if (event.key === 'ArrowLeft') { this.maze.slide_row(this.maze.selected_slide_row, 'left'); moved = true; }
                    else if (event.key === 'ArrowRight') { this.maze.slide_row(this.maze.selected_slide_row, 'right'); moved = true; }
                } else if (this.maze.selected_slide_col !== null) {
                    if (event.key === 'ArrowUp') { this.maze.slide_column(this.maze.selected_slide_col, 'up'); moved = true; }
                    else if (event.key === 'ArrowDown') { this.maze.slide_column(this.maze.selected_slide_col, 'down'); moved = true; }
                }
                if (moved) {
                    this.maze.selected_slide_row = null; this.maze.selected_slide_col = null; // Deselect after move
                    this.updatePlayerPosition(); this.hideMessage(); this.update();
                } else if (event.key.toLowerCase() === 'r') { this.resetCurrentLevel(); }
                this.draw();
            }

            updatePlayerPosition() { this.player.update_position_px(this.maze.get_cell_center_coords(this.maze.player_pos_grid[0], this.maze.player_pos_grid[1])); }

            update() {
                if (!this.gameActive || this.levelComplete || this.gameOver) return;
                if (this.maze.check_win()) {
                    this.levelComplete = true; this.gameActive = false; this.stopLoop();
                    this.showMessage("¡Nivel Completado! ", 'success'); playSound(smWinSound, ['D5', 'F#5', 'A5'], '0.4s');
                    if (this.currentLevelIndex + 1 > this.userStats.slidingPuzzle.highestLevelReached) {
                        this.userStats.slidingPuzzle.highestLevelReached = this.currentLevelIndex + 1;
                        this.addToLeaderboardCallback(currentLoggedInPlayer, this.userStats.slidingPuzzle.highestLevelReached, 'slidingPuzzle');
                    }
                    this.userStats.slidingPuzzle.currentLevel = this.currentLevelIndex + 1; // Advance to next level for saving
                    this.saveDataCallback(); updateSelectionScreenStats();
                    this.checkMedalCallback("sm_first_level"); this.checkMedalCallback("sm_level_3");
                    smNextBtn.style.display = 'inline-block'; smResetBtn.style.display = 'none';
                    if (Math.random() < SLIDING_PUZZLE_LOOT_BOX_PROBABILITY) setTimeout(triggerLootBox, 1000);
                }
            }
            draw() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); if (this.maze) { this.maze.draw(this.ctx); this.player.draw(this.ctx); } }
            loop() { this.update(); this.draw(); if (this.gameActive || this.levelComplete || this.gameOver) { this.animationFrameId = requestAnimationFrame(this.boundLoop); } }
            updateDisplay() { smLevelDisplay.textContent = this.currentLevelIndex + 1; smHighestLevelDisplay.textContent = this.userStats.slidingPuzzle.highestLevelReached || 0; }
            showMessage(text, type) { smGameMessageElem.textContent = text; smGameMessageElem.className = `sm-game-message sm-message-${type} show`; }
            hideMessage() { smGameMessageElem.classList.remove('show'); }
            pauseGameForScreenChange() {
                this.gameActive = false; this.stopLoop(); this.hideMessage();
                smStartBtn.style.display = 'inline-block'; smResetBtn.style.display = 'none'; smNextBtn.style.display = 'none';
                smStartBtn.textContent = 'Comenzar';
            }
        }

        function startSlidingMazeGame() {
            playSound(gameStartSound, 'G4', '0.4s');
            const userStats = getUserStats(); if (!userStats) return;
            if (!userStats.slidingPuzzle) userStats.slidingPuzzle = defaultPlayerStats().slidingPuzzle; // Initialize if new
            if (!smGameInstance) {
                smGameInstance = new SlidingMazeGame(userStats, saveAllUsersData, checkAndAwardMedal, addToLeaderboard);
            } else {
                smGameInstance.userStats = userStats;
                smGameInstance.currentLevelIndex = userStats.slidingPuzzle.currentLevel || 0; // Ensure current level is up-to-date
            }
            smGameInstance.startGame(); // Always call startGame to properly initialize or reset
        }


        // --- Utility, Saving, Loading ---
        function triggerLootBox() {
            const userStats = getUserStats(); if (!userStats) return;
            playSound(lootBoxSound, ['C4', 'E4', 'G4'], '0.4s');
            lootBoxModal.classList.add('visible');
            lootBoxRewardText.textContent = "Abriendo...";
            setTimeout(() => {
                const rewards = ["+1 Vida Extra (Mates)", "Bonus de Racha (Mates)", "Bonus de Tiempo Inicial (Mates)"];
                const randomReward = rewards[Math.floor(Math.random() * rewards.length)];
                lootBoxRewardText.textContent = `¡Has ganado: ${randomReward}!`;

                let notificationMsg = `¡Recompensa obtenida: ${randomReward}!`;
                if (randomReward.includes("Vida Extra") && userStats.math.playerLives < INITIAL_LIVES + 2) {
                    userStats.math.playerLives++;
                } else if (randomReward.includes("Racha")) {
                    userStats.inventory.push("bonus_racha_mates");
                    notificationMsg = "¡Bonus de Racha añadido a tu inventario!";
                } else if (randomReward.includes("Tiempo Inicial")) {
                    userStats.inventory.push("bonus_tiempo_inicio_mates");
                    notificationMsg = "¡Bonus de Tiempo Inicial añadido!";
                }
                showNotification(notificationMsg, "event", 2500);
                if (activeGame === 'math') updateMathGameDisplay(); // Update display if math game is active
                saveAllUsersData();
            }, 1500);
        }

        function closeLootBox() {
            playClickSound();
            lootBoxModal.classList.remove('visible');
        }

        function showNotification(message, type = 'success', duration = 3000) {
            notificationDisplay.textContent = message;
            notificationDisplay.className = 'notification show ' + type;
            setTimeout(() => {
                notificationDisplay.classList.remove('show');
            }, duration);
        }

        const MAX_LEADERBOARD_ENTRIES_DISPLAY = 5; // How many to show
        const MAX_LEADERBOARD_ENTRIES_STORE = 10; // How many to keep in storage for fairness
        let globalLeaderboard = { math: [], simon: [], numberMemory: [], slidingPuzzle: [] };

        function updateLeaderboardDisplay() {
            leaderboardList.innerHTML = ''; // Clear previous entries
            const gameTypesForLeaderboard = [
                { key: 'math', title: 'Mates (Mejor Racha)', color: '#5A67D8', scoreSuffix: '' },
                { key: 'simon', title: 'Simón (Puntuación Máx.)', color: '#38A169', scoreSuffix: '' },
                { key: 'numberMemory', title: 'Mem. Números (Puntuación Máx.)', color: '#805AD5', scoreSuffix: '' },
                { key: 'slidingPuzzle', title: 'Laberinto (Nivel Más Alto)', color: '#B7791F', scorePrefix: 'Nivel ' }
            ];

            let hasAnyScores = false;
            gameTypesForLeaderboard.forEach(game => {
                const boardData = (globalLeaderboard[game.key] || [])
                    .sort((a, b) => b.score - a.score) // Sort descending
                    .slice(0, MAX_LEADERBOARD_ENTRIES_DISPLAY);

                if (boardData.length > 0) {
                    hasAnyScores = true;
                    const titleLi = document.createElement('li');
                    titleLi.innerHTML = `<strong>${game.title}</strong>`;
                    titleLi.style.textAlign = 'center';
                    titleLi.style.fontWeight = 'bold';
                    titleLi.style.paddingTop = leaderboardList.children.length > 0 ? '10px' : '0'; // Add top padding if not first title
                    titleLi.style.paddingBottom = '5px';
                    titleLi.style.color = game.color;
                    leaderboardList.appendChild(titleLi);

                    boardData.forEach(entry => {
                        const li = document.createElement('li');
                        li.classList.add('leaderboard-item');
                        if (entry.name === currentLoggedInPlayer) li.classList.add('you'); // Highlight current player
                        const scoreDisplay = `${game.scorePrefix || ''}${entry.score}${game.scoreSuffix || ''}`;
                        li.innerHTML = `<span>${entry.name}</span> <strong>${scoreDisplay}</strong>`;
                        leaderboardList.appendChild(li);
                    });
                }
            });

            if (!hasAnyScores) {
                leaderboardList.innerHTML = '<li class="leaderboard-item" style="text-align:center; color:#888;">Aún no hay puntajes.</li>';
            }
        }

        function addToLeaderboard(name, score, gameType) {
            if (!globalLeaderboard[gameType]) globalLeaderboard[gameType] = [];
            const board = globalLeaderboard[gameType];
            const existingEntryIndex = board.findIndex(entry => entry.name === name);

            if (existingEntryIndex !== -1) { // Player exists
                if (score > board[existingEntryIndex].score) { // Update if new score is higher
                    board[existingEntryIndex].score = score;
                } else { return; } // No update needed
            } else { // New player
                board.push({ name, score });
            }

            board.sort((a, b) => b.score - a.score); // Sort descending
            if (board.length > MAX_LEADERBOARD_ENTRIES_STORE) { // Keep only top N entries
                globalLeaderboard[gameType] = board.slice(0, MAX_LEADERBOARD_ENTRIES_STORE);
            }
            updateLeaderboardDisplay();
            saveAllUsersData();
        }

        function updateMedalsDisplay() {
            const userStats = getUserStats(); if (!userStats) return;
            medalsList.innerHTML = ''; // Clear previous medals
            MEDALS.forEach(medal => {
                const isUnlocked = userStats.medals.includes(medal.id);
                const medalDiv = document.createElement('div');
                medalDiv.classList.add('medal-item');
                medalDiv.textContent = medal.icon; // Display emoji icon

                const tooltipSpan = document.createElement('span');
                tooltipSpan.classList.add('medal-tooltip');
                tooltipSpan.textContent = `${medal.name}${isUnlocked ? '' : ' (Bloqueada)'} - ${medal.description}`;
                medalDiv.appendChild(tooltipSpan);

                if (!isUnlocked) medalDiv.classList.add('locked');
                medalsList.appendChild(medalDiv);
            });
        }

        function checkAndAwardMedal(medalId) {
            const userStats = getUserStats(); if (!userStats) return;
            const medal = MEDALS.find(m => m.id === medalId);
            if (medal && !userStats.medals.includes(medalId) && medal.condition(userStats)) {
                userStats.medals.push(medalId);
                showNotification(`¡Medalla Desbloqueada: ${medal.name} ${medal.icon}!`, 'medal', 4000);
                playSound(medalSound, ['C5', 'G5', 'E5'], '0.4s');
                updateMedalsDisplay(); // Refresh display
                saveAllUsersData();
            }
        }

        function checkAndAwardAllMedals() { // Call this after significant game events
            const userStats = getUserStats(); if (!userStats) return;
            MEDALS.forEach(medal => {
                if (!userStats.medals.includes(medal.id) && medal.condition(userStats)) {
                    checkAndAwardMedal(medal.id); // This will handle notification and saving
                }
            });
        }

        function checkDailyBonus() {
            const userStats = getUserStats();
            if (!userStats) return;
            const todayDateStr = new Date().toISOString().split('T')[0]; // YYYY-MM-DD

            // Show bonus if it's a new day (lastLoginDate is today) AND bonus hasn't been collected today
            if (userStats.lastLoginDate === todayDateStr && userStats.lastBonusCollectedDate !== todayDateStr) {
                dailyBonusCardContainer.style.display = 'block';
                dailyBonusContainer.style.display = 'block';
                const bonusOptions = ["+1 Vida (Mates)", "Bonus de Racha (Mates)", "Bonus de Tiempo Inicial (Mates)"];
                const randomBonus = bonusOptions[Math.floor(Math.random() * bonusOptions.length)];
                dailyBonusMessage.textContent = `¡Tu recompensa de hoy es: ${randomBonus}!`;
                dailyBonusContainer.dataset.pendingBonus = randomBonus; // Store for collection
            } else {
                dailyBonusCardContainer.style.display = 'none';
                dailyBonusContainer.style.display = 'none';
            }
        }

        function collectDailyBonus() {
            playClickSound();
            const userStats = getUserStats(); if (!userStats) return;
            const pendingBonus = dailyBonusContainer.dataset.pendingBonus;

            if (pendingBonus) {
                let notificationMsg = `¡Bonificación reclamada: ${pendingBonus}!`;
                playSound(dailyBonusSound, ['D4', 'F#4', 'A4'], '0.5s');

                if (pendingBonus.includes("Vida") && userStats.math.playerLives < INITIAL_LIVES + 2) {
                    userStats.math.playerLives++;
                } else if (pendingBonus.includes("Racha")) {
                    userStats.inventory.push("bonus_racha_mates");
                    notificationMsg = "¡Bonus de Racha añadido a tu inventario!";
                } else if (pendingBonus.includes("Tiempo Inicial")) {
                    userStats.inventory.push("bonus_tiempo_inicio_mates");
                    notificationMsg = "¡Bonus de Tiempo Inicial añadido!";
                }
                showNotification(notificationMsg, "event", 2500);
                userStats.lastBonusCollectedDate = new Date().toISOString().split('T')[0]; // Mark bonus collected for today
                if (activeGame === 'math') updateMathGameDisplay();
                saveAllUsersData();
                dailyBonusCardContainer.style.display = 'none'; // Hide after collection
                dailyBonusContainer.style.display = 'none';
            }
        }


        const SAVE_KEY = 'mentalChallengesUserData_v10'; // Incremented for new stat structure
        function saveAllUsersData() {
            try {
                const dataToSave = { users: allUsersData, leaderboard: globalLeaderboard };
                localStorage.setItem(SAVE_KEY, JSON.stringify(dataToSave));
            } catch (e) {
                console.error("Error saving data:", e);
                showNotification("Error al guardar progreso.", "error", 5000);
            }
        }

        function loadAllUsersData() {
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    allUsersData = parsedData.users || {};
                    globalLeaderboard = parsedData.leaderboard || { math: [], simon: [], numberMemory: [], slidingPuzzle: [] };

                    // Ensure all game types exist in leaderboard object
                    ['math', 'simon', 'numberMemory', 'slidingPuzzle'].forEach(gameKey => {
                        if (!globalLeaderboard[gameKey]) globalLeaderboard[gameKey] = [];
                    });

                    // Data migration/initialization for existing users
                    Object.values(allUsersData).forEach(userData => {
                        const defaultStatsTemplate = defaultPlayerStats(); // Get a fresh template
                        if (!userData.stats) {
                            userData.stats = defaultStatsTemplate; // Assign full default if stats obj missing
                        } else {
                            // Merge: Ensure all keys from defaultStatsTemplate exist in userData.stats
                            for (const key in defaultStatsTemplate) {
                                if (userData.stats[key] === undefined) {
                                    userData.stats[key] = defaultStatsTemplate[key];
                                } else if (typeof defaultStatsTemplate[key] === 'object' &&
                                           defaultStatsTemplate[key] !== null &&
                                           !Array.isArray(defaultStatsTemplate[key])) {
                                    // For nested objects (like game stats), ensure sub-keys
                                    for (const subKey in defaultStatsTemplate[key]) {
                                        if (userData.stats[key][subKey] === undefined) {
                                            userData.stats[key][subKey] = defaultStatsTemplate[key][subKey];
                                        }
                                    }
                                }
                            }
                        }
                    });

                } else { // No saved data, initialize fresh
                    allUsersData = {};
                    globalLeaderboard = { math: [], simon: [], numberMemory: [], slidingPuzzle: [] };
                }
            } catch (e) {
                console.error("Error loading data:", e);
                showNotification("Error al cargar datos. Se iniciarán nuevos datos.", "error", 5000);
                allUsersData = {}; // Reset on error
                globalLeaderboard = { math: [], simon: [], numberMemory: [], slidingPuzzle: [] };
            }
        }


        // Event Listeners
        mathUserAnswerInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') checkMathAnswer();
        });

        Object.values(simonPadElements).forEach(pad => {
            pad.addEventListener('click', handleSimonPadClick);
        });


        window.onload = () => {
            loadAllUsersData();
            updateLeaderboardDisplay(); // Initial display of leaderboard from loaded data
            showScreen('welcome'); // Start at the welcome screen
        };
    </script>
</body>
</html>
